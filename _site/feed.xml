<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>唐静</title>
    <description>2年RN，3年前端。</description>
    <link>http://localhost:4000/</link>
    <atom:link href="http://localhost:4000/feed.xml" rel="self" type="application/rss+xml"/>
    <pubDate>Mon, 12 Apr 2021 16:45:01 +0800</pubDate>
    <lastBuildDate>Mon, 12 Apr 2021 16:45:01 +0800</lastBuildDate>
    <generator>Jekyll v3.8.5</generator>
    
      <item>
        <title>2021-04-12-谈谈vue-router</title>
        <description>&lt;h3 id=&quot;vue-router-对不同模式的实现大致是这样的&quot;&gt;vue-router 对不同模式的实现大致是这样的：&lt;/h3&gt;

&lt;ol&gt;
  &lt;li&gt;首先根据 mode 来确定所选的模式，如果当前环境不支持 history 模式，会强制切换到 hash 模式；&lt;/li&gt;
  &lt;li&gt;如果当前环境不是浏览器环境，会切换到 abstract 模式下。然后再根据不同模式来生成不同的 history 操作对象。&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;new-vuerouter-过程&quot;&gt;new VueRouter 过程&lt;/h3&gt;

&lt;ol&gt;
  &lt;li&gt;init 方法内的 app 变量便是存储的当前的 vue 实例的 this。&lt;/li&gt;
  &lt;li&gt;将 app 存入数组 apps 中。通过 this.app 判断是实例否已经被初始化。&lt;/li&gt;
  &lt;li&gt;通过 history 来确定不同路由的切换动作 history.transitionTo。&lt;/li&gt;
  &lt;li&gt;通过 history.listen 来注册路由变化的响应回调。&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;hash-和-history-的区别&quot;&gt;hash 和 history 的区别&lt;/h3&gt;

&lt;ol&gt;
  &lt;li&gt;最明显的是在显示上，hash 模式的 URL 中会夹杂着#号，而 history 没有。&lt;/li&gt;
  &lt;li&gt;Vue 底层对它们的实现方式不同。hash 模式是依靠 onhashchange 事件(监听 location.hash 的改变)，而 history 模式（popstate）是主要是依靠的 HTML5 history 中新增的两个方法，pushState()可以改变 url 地址且不会发送请求，replaceState()可以读取历史记录栈，还可以对浏览器记录进行修改。&lt;/li&gt;
  &lt;li&gt;当真正需要通过 URL 向后端发送 HTTP 请求的时候，比如常见的用户手动输入 URL 后回车，或者是刷新(重启)浏览器，这时候 history 模式需要后端的支持。因为 history 模式下，前端的 URL 必须和实际向后端发送请求的 URL 一致，例如有一个 URL 是带有路径 path 的(例如www.lindaidai.wang/blogs/id)，如果后端没有对这个路径做处理的话，就会返回404错误。所以需要后端增加一个覆盖所有情况的候选资源，一般会配合前端给出的一个404页面。&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;vue-history-配置&quot;&gt;vue history 配置&lt;/h3&gt;

&lt;p&gt;vue history 需要 nginx 或者其他方式配置一下才可正确访问，否则路由跳转之后刷新一下便会出现 404。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;vue history 模式 部署在服务器端的 nginx 配置 (非根目录)配置如下：&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;server {

        listen      443 ;

        server_name  m;

        root  html/mobile;

        location / {

            index  index.html index.htm;

            try_files $uri $uri/ /index.html;

        }

    }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;路由配置：&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;const router=new VueRouter({
  mode: 'history',
  routes
})
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
</description>
        <pubDate>Mon, 12 Apr 2021 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2021/04/%E8%B0%88%E8%B0%88vueRouter/</link>
        <guid isPermaLink="true">http://localhost:4000/2021/04/%E8%B0%88%E8%B0%88vueRouter/</guid>
        
        <category>#vue,</category>
        
        <category>#vue-router,</category>
        
        <category>#hash,</category>
        
        <category>#history</category>
        
        
      </item>
    
      <item>
        <title>2021-04-12-vue和react diff 算法对比</title>
        <description>&lt;h3 id=&quot;react-diff-算法&quot;&gt;react diff 算法&lt;/h3&gt;

&lt;p&gt;当调用 React 的 render()方法时，会创建一棵由 React 元素组成的树。在下一次 State 或 Props 更新时，相同的 render()方法会返回一棵不同的树。React 会应用 Diffing 算法来高效的比较两棵树，算法过程如下：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;当根节点为不同类型的元素时，React 会拆卸原有的树，销毁对应的 DOM 节点和关联的 State、卸载子组件，最后再创建新的树。&lt;/li&gt;
  &lt;li&gt;当比对两个相同类型的 DOM 元素时，会保留 DOM 节点，仅比对变更的属性。&lt;/li&gt;
  &lt;li&gt;当比对两个相同类型的组件元素时，组件实例保持不变，更新该组件实例的 Props。&lt;/li&gt;
  &lt;li&gt;当递归 DOM 节点的子元素时，React 会同时遍历两个子元素的列表，比对相同位置的元素，性能比较低效。&lt;/li&gt;
  &lt;li&gt;在给子元素添加唯一标识的 key 属性后，就能只比对变更了 key 属性的元素。&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;vue20-diff-算法&quot;&gt;vue2.0 diff 算法&lt;/h3&gt;

&lt;ol&gt;
  &lt;li&gt;先同级比较再比较子节点&lt;/li&gt;
  &lt;li&gt;先判断一方有子节点和一方没有子节点的情况。如果新的一方有子节点，旧的一方没有，相当于新的子节点替代了原来没有的节点；同理，如果新的一方没有子节点，旧的一方有，相当于要把老的节点删除。&lt;/li&gt;
  &lt;li&gt;再来比较都有子节点的情况，这里是 diff 的核心。首先会通过判断两个节点的 key、tag、isComment、data 同时定义或不定义以及当标签类型为 input 的时候 type 相不相同来确定两个节点是不是相同的节点，如果不是的话就将新节点替换旧节点。&lt;/li&gt;
  &lt;li&gt;如果是相同节点的话才会进入到 patchVNode 阶段。在这个阶段核心是采用【双指针】的算法，同时从新旧节点的两端进行比较，在这个过程中，会用到模版编译时的静态标记配合 key 来跳过对比静态节点，如果不是的话再进行其它的比较。&lt;/li&gt;
&lt;/ol&gt;

&lt;ul&gt;
  &lt;li&gt;** 缺点：因为采用的是同级比较，所以如果发现本级的节点不同的话就会将新节点直接替换旧节点，不会再去比较其下的子节点是否有相同 **&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;vue2vue3-和-react-比较&quot;&gt;vue2、vue3 和 react 比较&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;vue2 和 vue3.x:
Vue3.x 借鉴了 ivi 算法和 inferno 算法。
它在创建 VNode 的时候就确定了其类型，以及在 mount/patch 的过程中采用位运算来判断一个 VNode 的类型，在这个基础之上再配合核心的 Diff 算法，使得性能上较 Vue2.x 有了提升。&lt;/li&gt;
  &lt;li&gt;vue 和 react:
共同点是：都是用同层比较，不同点是：vue 使用双指针比较，react 是用 key 集合级比较。&lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Mon, 12 Apr 2021 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2021/04/vue%E5%92%8Creact-diff-%E7%AE%97%E6%B3%95%E5%AF%B9%E6%AF%94/</link>
        <guid isPermaLink="true">http://localhost:4000/2021/04/vue%E5%92%8Creact-diff-%E7%AE%97%E6%B3%95%E5%AF%B9%E6%AF%94/</guid>
        
        <category>#vue2.0,</category>
        
        <category>#vue3.0,</category>
        
        <category>#react</category>
        
        
      </item>
    
      <item>
        <title>2021-04-12-vue computed 属性为什么能够在依赖改变的时候，自己发生变化</title>
        <description>&lt;h3 id=&quot;vue-computed-属性为什么能够在依赖改变的时候自己发生变化&quot;&gt;Vue computed 属性为什么能够在依赖改变的时候，自己发生变化？&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/0412/1.png&quot; alt=&quot;1.png&quot; /&gt;
computed 和 watch 公用一个 Watcher 类，在 computed 的情况下有一个 deps 。 Vue 在二次收集依赖时用 cleanupDeps 在每次添加完新的订阅，会移除掉旧的订阅。&lt;/p&gt;

&lt;p&gt;查看&lt;a href=&quot;https://zhuanlan.zhihu.com/p/45081605&quot;&gt;‘收集依赖’&lt;/a&gt;是什么意思&lt;/p&gt;
</description>
        <pubDate>Mon, 12 Apr 2021 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2021/04/vue-computed-%E5%B1%9E%E6%80%A7%E4%B8%BA%E4%BB%80%E4%B9%88%E8%83%BD%E5%A4%9F%E5%9C%A8%E4%BE%9D%E8%B5%96%E6%94%B9%E5%8F%98%E7%9A%84%E6%97%B6%E5%80%99-%E8%87%AA%E5%B7%B1%E5%8F%91%E7%94%9F%E5%8F%98%E5%8C%96/</link>
        <guid isPermaLink="true">http://localhost:4000/2021/04/vue-computed-%E5%B1%9E%E6%80%A7%E4%B8%BA%E4%BB%80%E4%B9%88%E8%83%BD%E5%A4%9F%E5%9C%A8%E4%BE%9D%E8%B5%96%E6%94%B9%E5%8F%98%E7%9A%84%E6%97%B6%E5%80%99-%E8%87%AA%E5%B7%B1%E5%8F%91%E7%94%9F%E5%8F%98%E5%8C%96/</guid>
        
        <category>#vue,</category>
        
        <category>#computed属性</category>
        
        
      </item>
    
      <item>
        <title>2021-04-08-一些电子书籍链接记录</title>
        <description>&lt;p&gt;一些电子书籍链接记录:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;a href=&quot;https://pan.baidu.com/s/1VZ2anKyMgm3gTkeYktpkaQ&quot;&gt;代码大全 2 中文版(完整清晰版).pdf&lt;/a&gt; 密码: lhpv&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://pan.baidu.com/s/1Thn91nCt23ymspWKyO7_qQ&quot;&gt;javascript 设计模式与开发实战.pdf（曾探）&lt;/a&gt; 密码: pd49&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://pan.baidu.com/s/1sdU6Uv2Nvppp2YEv8zUZzw&quot;&gt;深入 react 技术栈.pdf&lt;/a&gt; 密码: 7o6b&lt;/li&gt;
&lt;/ol&gt;
</description>
        <pubDate>Tue, 06 Apr 2021 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2021/04/%E7%94%B5%E5%AD%90%E4%B9%A6%E7%B1%8D%E5%BD%95/</link>
        <guid isPermaLink="true">http://localhost:4000/2021/04/%E7%94%B5%E5%AD%90%E4%B9%A6%E7%B1%8D%E5%BD%95/</guid>
        
        <category>#电子书籍</category>
        
        
      </item>
    
      <item>
        <title>2021-04-08-Object.create()使用及探究</title>
        <description>&lt;p&gt;前言：在看 js 设计模式的时候，有提到：JavaScript 没有提供传统面向对象语言中的类式继承，而是通过原型委托的方式来实现对象
与对象之间的继承。
委托是一种利用 Object.create 与对象方式实现的 js 类多态方式。&lt;/p&gt;

&lt;p&gt;例如，我们最近正在做的轻量化引擎里面就有这样的应用：OrbitControls.prototype = Object.create( EventDispatcher.prototype );&lt;/p&gt;

&lt;h3 id=&quot;objectcreateproto-propertiesobject&quot;&gt;Object.create(proto, [propertiesObject])&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;参数：proto : 必须。表示新建对象的原型对象，即该参数会被赋值到目标对象(即新对象，或说是最后返回的对象)的原型上。该参数可以是&lt;code class=&quot;highlighter-rouge&quot;&gt;null&lt;/code&gt;， &lt;code class=&quot;highlighter-rouge&quot;&gt;对象&lt;/code&gt;， 函数的&lt;code class=&quot;highlighter-rouge&quot;&gt;prototype属性&lt;/code&gt; （创建空的对象时需传 null , 否则会抛出&lt;code class=&quot;highlighter-rouge&quot;&gt;TypeError&lt;/code&gt;异常）。&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;propertiesObject : 可选。 添加到新创建对象的可枚举属性（即其自身的属性，而不是原型链上的枚举属性）对象的属性描述符以及相应的属性名称。这些属性对应&lt;a href=&quot;https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperties&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Object.defineProperties()&lt;/code&gt;&lt;/a&gt;的第二个参数。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;先使用一波
&lt;img src=&quot;/assets/images/0408/1.png&quot; alt=&quot;1.png&quot; /&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;给对象原型添加属性和方法&lt;/li&gt;
&lt;/ul&gt;

&lt;ol&gt;
  &lt;li&gt;使用 Object.create()给对象原型添加属性和方法：&lt;/li&gt;
&lt;/ol&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;var proto = {
	x:1,
	y:2,
	showNum(){}
}
var o = Object.create(proto)
console.log(o) // 结果见截图
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/0408/2.png&quot; alt=&quot;2.png&quot; /&gt;&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;如果不是使用 Object.create()方法，我们是如何给对象原型添加属性和方法的呢？&lt;/li&gt;
&lt;/ol&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;// 创建一个构造函数或者类
var People = function(){}
People.prototype.x = 1
People.prototype.t = 2
People.prototype.showNum = function(){}
// 通过构造函数创建实例
var p = new People()
console.log(p.__proto__ === People.prototype) // true
console.log(p) //结果见截图
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/0408/3.png&quot; alt=&quot;3.png&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;再看下面一段代码（原型属性的继承）：&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;var triangle = {a: 1, b: 2, c: 3};

function ColoredTriangle() {
  this.color = 'red';
}

// ColoredTriangle.prototype = triangle;  // ColoredTriangle.prototype.constructor === ColoredTriangle // false

Object.assign(ColoredTriangle.prototype, triangle) // ColoredTriangle.prototype.constructor === ColoredTriangle // true

var c = new ColoredTriangle();
console.log(c) // 这里打印出c可以看看结构。其中color属性在实例上，而其他的在原型上。如下图：
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/0408/4.png&quot; alt=&quot;4.png&quot; /&gt;&lt;/p&gt;

&lt;p&gt;再来拷贝一个实例 c3:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;var c3 = Object.assign({}, c)
console.log(c3.color) // red
console.log(c3.a) // undefined
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/0408/5.png&quot; alt=&quot;5.png&quot; /&gt;&lt;/p&gt;

&lt;p&gt;因为 Object.assign 是不能拷贝到继承或原型上的方法的。&lt;/p&gt;

&lt;p&gt;所以 c3 没有 a 这个属性。那要怎么样才能拷贝原型上的方法呢？见下：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;var c2 = Object.create(Object.getPrototypeOf(c), Object.getOwnPropertyDescriptors(c));

console.log(c2) // 结果见下图
console.log(c2.color); // red
console.log(c2.a); // 1
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/0408/6.png&quot; alt=&quot;6.png&quot; /&gt;&lt;/p&gt;

&lt;p&gt;可以把 Object.create()的参数理解为：第一个参数是放在新对象的原型上的，第二个参数是放在新对象的实例上的。
所以上面例子 Object.getPrototypeOf() 得到的是 c 对象的原型，然后作为第一个参数，所以会在新对象 c2 的原型上。
Object.getOwnPropertyDescriptors() 得到是 c 对象自身的可枚举属性，作为第二个参数，放在 c2 的实例上。
为什么说推荐这个方法呢？因为 Object.assign() 方法不能正确拷贝 get ，set 属性。&lt;/p&gt;

&lt;p&gt;上面实现 原型属性拷贝 中的两种方法中用到了 &lt;code class=&quot;highlighter-rouge&quot;&gt;Object.getOwnPropertyDescriptors&lt;/code&gt; 、&lt;code class=&quot;highlighter-rouge&quot;&gt;Object.assing()&lt;/code&gt; 、&lt;code class=&quot;highlighter-rouge&quot;&gt;Object.create&lt;/code&gt;、&lt;code class=&quot;highlighter-rouge&quot;&gt;Object.getPrototypeOf()&lt;/code&gt;方法，通常这几种方法都有一起结合使用。&lt;/p&gt;
</description>
        <pubDate>Tue, 06 Apr 2021 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2021/04/Object.create()%E4%BD%BF%E7%94%A8%E4%B8%8E%E6%8E%A2%E7%A9%B6/</link>
        <guid isPermaLink="true">http://localhost:4000/2021/04/Object.create()%E4%BD%BF%E7%94%A8%E4%B8%8E%E6%8E%A2%E7%A9%B6/</guid>
        
        <category>#Object.create(),</category>
        
        <category>#js设计模式（代理模式）</category>
        
        
      </item>
    
      <item>
        <title>2021-04-06-iphone各机型屏幕尺寸（包含最新iphone12）</title>
        <description>&lt;p&gt;前言：更新 iphone 各机型屏幕尺寸列表（包含最新 iphone12）&lt;/p&gt;

&lt;h3 id=&quot;iphone-各机型屏幕尺寸如下所示&quot;&gt;iphone 各机型屏幕尺寸如下所示&lt;/h3&gt;

&lt;table&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;手机设备型号&lt;/td&gt;
      &lt;td&gt;屏幕尺寸&lt;/td&gt;
      &lt;td&gt;分辨率点数（pt）&lt;/td&gt;
      &lt;td&gt;屏幕显示模式&lt;/td&gt;
      &lt;td&gt;分辨率像素（px）&lt;/td&gt;
      &lt;td&gt;屏幕比例&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;iPhone SE&lt;/td&gt;
      &lt;td&gt;4.0 吋&lt;/td&gt;
      &lt;td&gt;320x568&lt;/td&gt;
      &lt;td&gt;@2x&lt;/td&gt;
      &lt;td&gt;640x1136&lt;/td&gt;
      &lt;td&gt;16:9&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;iPhone 6/6s/7/8/SE 2&lt;/td&gt;
      &lt;td&gt;4.7 吋&lt;/td&gt;
      &lt;td&gt;375x667&lt;/td&gt;
      &lt;td&gt;@2x&lt;/td&gt;
      &lt;td&gt;750x1334&lt;/td&gt;
      &lt;td&gt;16:9&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;iPhone 6p/7p/8p&lt;/td&gt;
      &lt;td&gt;5.5 吋&lt;/td&gt;
      &lt;td&gt;414x736&lt;/td&gt;
      &lt;td&gt;@3x&lt;/td&gt;
      &lt;td&gt;1242x2208&lt;/td&gt;
      &lt;td&gt;16:9&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;iPhone XR/11&lt;/td&gt;
      &lt;td&gt;6.1 吋&lt;/td&gt;
      &lt;td&gt;414x896&lt;/td&gt;
      &lt;td&gt;@2x&lt;/td&gt;
      &lt;td&gt;828x1792&lt;/td&gt;
      &lt;td&gt;19.5:9&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;iPhone X/XS/11 Pro&lt;/td&gt;
      &lt;td&gt;5.8 吋&lt;/td&gt;
      &lt;td&gt;375x812&lt;/td&gt;
      &lt;td&gt;@3x&lt;/td&gt;
      &lt;td&gt;1125x2436&lt;/td&gt;
      &lt;td&gt;19.5:9&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;iPhone XS Max/11 Pro Max&lt;/td&gt;
      &lt;td&gt;6.5 吋&lt;/td&gt;
      &lt;td&gt;414x896&lt;/td&gt;
      &lt;td&gt;@3x&lt;/td&gt;
      &lt;td&gt;1242x2688&lt;/td&gt;
      &lt;td&gt;19.5:9&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;iPhone 12 mini&lt;/td&gt;
      &lt;td&gt;5.4 吋&lt;/td&gt;
      &lt;td&gt;360x780&lt;/td&gt;
      &lt;td&gt;@3x&lt;/td&gt;
      &lt;td&gt;1080x2340&lt;/td&gt;
      &lt;td&gt;19.5:9&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;iPhone 12/12 Pro&lt;/td&gt;
      &lt;td&gt;6.1 吋&lt;/td&gt;
      &lt;td&gt;390x844&lt;/td&gt;
      &lt;td&gt;@3x&lt;/td&gt;
      &lt;td&gt;1170x2532&lt;/td&gt;
      &lt;td&gt;19.5:9&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;iPhone 12 Pro Max&lt;/td&gt;
      &lt;td&gt;6.7 吋&lt;/td&gt;
      &lt;td&gt;428x926&lt;/td&gt;
      &lt;td&gt;@3x&lt;/td&gt;
      &lt;td&gt;1284x2778&lt;/td&gt;
      &lt;td&gt;19.5:9&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;
</description>
        <pubDate>Tue, 06 Apr 2021 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2021/04/iphone%E5%90%84%E6%9C%BA%E5%9E%8B%E5%B1%8F%E5%B9%95%E5%B0%BA%E5%AF%B8-%E5%8C%85%E5%90%AB%E6%9C%80%E6%96%B0iphone12/</link>
        <guid isPermaLink="true">http://localhost:4000/2021/04/iphone%E5%90%84%E6%9C%BA%E5%9E%8B%E5%B1%8F%E5%B9%95%E5%B0%BA%E5%AF%B8-%E5%8C%85%E5%90%AB%E6%9C%80%E6%96%B0iphone12/</guid>
        
        <category>#ios,</category>
        
        <category>#iphone,</category>
        
        <category>#屏幕尺寸</category>
        
        
      </item>
    
      <item>
        <title>2021-04-06-ios完整的 statusbar 高度的表</title>
        <description>&lt;p&gt;前言：更新 iphone 各机型屏幕尺寸列表（包含最新 iphone12）&lt;/p&gt;

&lt;h3 id=&quot;iphone-各机型屏幕尺寸如下所示&quot;&gt;iphone 各机型屏幕尺寸如下所示&lt;/h3&gt;

&lt;table&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;设备&lt;/td&gt;
      &lt;td&gt;statusbar 高度&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;iPhone11&lt;/td&gt;
      &lt;td&gt;48&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;iPhone12/12 pro/12 pro max&lt;/td&gt;
      &lt;td&gt;47&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;iPhone12 mini&lt;/td&gt;
      &lt;td&gt;50&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;iPad Pro、IPad Air&lt;/td&gt;
      &lt;td&gt;24&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Other iPhones&lt;/td&gt;
      &lt;td&gt;44&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;非刘海屏&lt;/td&gt;
      &lt;td&gt;20&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;
</description>
        <pubDate>Tue, 06 Apr 2021 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2021/04/ios%E5%AE%8C%E6%95%B4%E7%9A%84-statusbar-%E9%AB%98%E5%BA%A6%E7%9A%84%E8%A1%A8/</link>
        <guid isPermaLink="true">http://localhost:4000/2021/04/ios%E5%AE%8C%E6%95%B4%E7%9A%84-statusbar-%E9%AB%98%E5%BA%A6%E7%9A%84%E8%A1%A8/</guid>
        
        <category>#ios,</category>
        
        <category>#iphone,</category>
        
        <category>#屏幕尺寸</category>
        
        
      </item>
    
      <item>
        <title>鼠标右键contextMenu事件在mac和windows上的不同</title>
        <description>&lt;p&gt;前言：在做一个自定义鼠标右键菜单的需求的时候，发现 contextMenu 事件在 mac 和 windows 平台上表现不一致。&lt;/p&gt;

&lt;h3 id=&quot;方法使用&quot;&gt;方法使用&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;区别&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;mac: 右键按下即触发 contextMenu event，鼠标抬起，触发 mouseUp event；&lt;/li&gt;
      &lt;li&gt;win: 右键按下抬起后，先触发 mouseUp event，然后触发 contextMenu event。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Wed, 31 Mar 2021 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2021/03/%E9%BC%A0%E6%A0%87%E5%8F%B3%E9%94%AEcontextMenu%E4%BA%8B%E4%BB%B6%E5%9C%A8mac%E5%92%8Cwindows%E4%B8%8A%E7%9A%84%E4%B8%8D%E5%90%8C/</link>
        <guid isPermaLink="true">http://localhost:4000/2021/03/%E9%BC%A0%E6%A0%87%E5%8F%B3%E9%94%AEcontextMenu%E4%BA%8B%E4%BB%B6%E5%9C%A8mac%E5%92%8Cwindows%E4%B8%8A%E7%9A%84%E4%B8%8D%E5%90%8C/</guid>
        
        <category>#鼠标右键事件,</category>
        
        <category>#contextMenu,#mac</category>
        
        <category>&amp;</category>
        
        <category>windows区别</category>
        
        
      </item>
    
      <item>
        <title>insertAdjacentHTML方法的使用</title>
        <description>&lt;p&gt;前言：我们常用 innerText &amp;amp; innerHTML 给一个 dom 元素插入一段文本或者 html。最近发现还有 insertAdjacentHTML 和 insertAdjacentText 方法，这两个方法更灵活，可以在指定的地方插入 html 内容和文本内容。（adjacent，这个单词是“相邻”的意思）&lt;/p&gt;

&lt;h3 id=&quot;方法使用&quot;&gt;方法使用&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;insertAdjacentHTML(swhere, stext)&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;swhere: 指定插入 html 标签语句的地方，有四个值可选：
        &lt;ul&gt;
          &lt;li&gt;beforeBegin:插入到标签开始标记前， 如：xxx&amp;lt;div&amp;gt;&lt;/li&gt;
          &lt;li&gt;afterBegin:插入到标签开始标记后，如：&amp;lt;div&amp;gt;xxx&lt;/li&gt;
          &lt;li&gt;beforeEnd:插入到标签结束标记前，如：xxx&amp;lt;/div&amp;gt;&lt;/li&gt;
          &lt;li&gt;afterEnd:插入到标签结束标记后, 如：&amp;lt;/div&amp;gt;xxx&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;stext: 要插入的内容&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;insertAdjacentText(swhere, stext)方法与 inserAdjacentHTML 方法类似，只不过只能插入纯文本，参数一样。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Tue, 30 Mar 2021 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2021/03/insertAdjacentHTML%E6%96%B9%E6%B3%95%E7%9A%84%E4%BD%BF%E7%94%A8/</link>
        <guid isPermaLink="true">http://localhost:4000/2021/03/insertAdjacentHTML%E6%96%B9%E6%B3%95%E7%9A%84%E4%BD%BF%E7%94%A8/</guid>
        
        <category>#insertAdjacentHTML,</category>
        
        <category>#insertAdjacentText,</category>
        
        
      </item>
    
      <item>
        <title>React17源码解读笔记</title>
        <description>&lt;p&gt;前言：好奇 react 虚拟 dom 的结构，到底长什么样？&lt;/p&gt;

&lt;h4 id=&quot;1fork-react-代码仓库&quot;&gt;1.fork react 代码仓库&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;注意，不要直接下载 React 仓库，先 fork 一份到自己仓库，然后再下载。这样可以修改或者增加注释之后，提交到自己仓库。&lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Thu, 25 Feb 2021 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2021/02/react17%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/</link>
        <guid isPermaLink="true">http://localhost:4000/2021/02/react17%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/</guid>
        
        <category>#react,</category>
        
        <category>#react源码,</category>
        
        <category>#react虚拟dom</category>
        
        
      </item>
    
  </channel>
</rss>
