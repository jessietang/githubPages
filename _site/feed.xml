<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>唐静</title>
    <description>2年RN，3年前端。</description>
    <link>http://localhost:4000/</link>
    <atom:link href="http://localhost:4000/feed.xml" rel="self" type="application/rss+xml"/>
    <pubDate>Tue, 11 May 2021 11:33:41 +0800</pubDate>
    <lastBuildDate>Tue, 11 May 2021 11:33:41 +0800</lastBuildDate>
    <generator>Jekyll v3.8.5</generator>
    
      <item>
        <title>react fiber</title>
        <description>&lt;h3 id=&quot;react-fiber-直接参考下面的文章目前见过讲得最好的一篇文章&quot;&gt;react fiber 直接参考下面的文章，目前见过讲得最好的一篇文章：&lt;/h3&gt;

&lt;p&gt;&lt;a href=&quot;http://www.ayqy.net/blog/dive-into-react-fiber/&quot;&gt;react fiber&lt;/a&gt;&lt;/p&gt;
</description>
        <pubDate>Sun, 09 May 2021 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2021/05/react-fiber/</link>
        <guid isPermaLink="true">http://localhost:4000/2021/05/react-fiber/</guid>
        
        <category>#react,</category>
        
        <category>#fiber</category>
        
        
      </item>
    
      <item>
        <title>（react）深入理解虚拟dom和diff算法</title>
        <description>&lt;h3 id=&quot;什么是虚拟-dom&quot;&gt;什么是虚拟 dom?&lt;/h3&gt;

&lt;p&gt;虚拟 dom 就是一个 js 对象。用 js 对象表示 DOM 信息和结构，当状态变更的时候，重新渲染这个 js 对象结构。这个 js 对象被称为 virtual dom.&lt;/p&gt;

&lt;h3 id=&quot;为什么要用虚拟-dom&quot;&gt;为什么要用虚拟 dom？&lt;/h3&gt;

&lt;p&gt;早先的时候，我们都是直接操作 dom（如：jquery）.&lt;/p&gt;

&lt;p&gt;这里，我们创建一个简单的 div，然后把他的所有的属性都打印出来：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    var div = document.createElement('div'),
        str = '';
    for (var key in div) {
      str = str + ' ' + key;
    }
    console.log(str);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;打印出来的结果：
&lt;img src=&quot;/assets/images/210509/divAttr.png&quot; alt=&quot;divAttr.png&quot; /&gt;
可以看到，这些属性还是非常惊人的，包括样式的修饰特性、一般的特性、方法等等，如果我们打印出其长度，可以得到惊人的 227 个。
而这仅仅是一层，真正的 DOM 元素是非常庞大的，这是因为标准就是这么设计的，而且操作他们的时候你要小心翼翼，轻微的触碰就有可能导致页面发生重排，这是杀死性能的罪魁祸首。&lt;/p&gt;

&lt;p&gt;而相对于 DOM 对象，原生的 JavaScript 对象处理起来更快，而且更简单，DOM 树上的结构信息我们都可以使用 JavaScript 对象很容易的表示出来。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;var element = {
      tagName: 'ul',
      props: {
        id: 'list'
      },
      children: {
        {
          tagName: 'li',
          props: {
            class: 'item'
          },
          children: ['Item1']
        },
        {
          tagName: 'li',
          props: {
            class: 'item'
          },
          children: ['Item1']
        },
        {
          tagName: 'li',
          props: {
            class: 'item'
          },
          children: ['Item1']
        }
      }
    }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;在哪里用到了虚拟-dom&quot;&gt;在哪里用到了虚拟 dom?&lt;/h3&gt;

&lt;p&gt;这就回到我们今天要说的。react 里面使用了虚拟 dom. React 里面就是把 jsx 转换成 js 对象。&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;jsx ?&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;
        &lt;p&gt;jsx 是一个语法糖，React 使用 jsx 来代替常规的 Javascript.
先看看使用 jsx 的代码：
&lt;img src=&quot;/assets/images/210509/jsx01.png&quot; alt=&quot;jsx01.png&quot; /&gt;&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;再看看不使用 jsx 的代码：
&lt;img src=&quot;/assets/images/210509/jsx02.png&quot; alt=&quot;jsx02.png&quot; /&gt;&lt;/p&gt;

        &lt;p&gt;react 里面使用 jsx 语法描述视图，通过 babel-loader 转译后它们变为 React.reateElement(…)形式。该函数将生成 vdom（虚拟 dom,即：js 对象）来描述真实 dom。如果状态发生变化，vdom 将作出相应的变化，再通过 diff 算法对比新老 vdom 区别从而作出最终 dom 的操作。
访问&lt;a href=&quot;https://www.babeljs.cn/repl#?browsers=defaults%2C%20not%20ie%2011%2C%20not%20ie_mob%2011&amp;amp;build=&amp;amp;builtIns=false&amp;amp;corejs=3.6&amp;amp;spec=false&amp;amp;loose=false&amp;amp;code_lz=MYewdgzgLgBFCWUA2BTGBeGAeAFgRhmCQEMIIA5YgWxXQCIFkU6A-ACRSSRABoYB3EACckAEwCEWAPT4WAbiA&amp;amp;debug=false&amp;amp;forceAllTransforms=false&amp;amp;shippedProposals=false&amp;amp;circleciRepo=&amp;amp;evaluate=false&amp;amp;fileSize=false&amp;amp;timeTravel=false&amp;amp;sourceType=module&amp;amp;lineWrap=true&amp;amp;presets=env%2Creact%2Cstage-2&amp;amp;prettier=false&amp;amp;targets=&amp;amp;version=7.14.1&amp;amp;externalPlugins=&quot;&gt;在线 babel 编辑器&lt;/a&gt;试一试。&lt;/p&gt;

        &lt;p&gt;如图示例：
&lt;img src=&quot;/assets/images/210509/babel.png&quot; alt=&quot;babel.png&quot; /&gt;&lt;/p&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;注意：
在 react17 之前，使用的是 React.createElement()进行 jsx 编译。
React17 中的 jsx 转换不会将 jsx 转换为 React.createElement(…),而是自动从 react 的 package 中引入新的函数并调用。另外，此次升级，不会改变 jsx 语法，旧的 jsx 转换也将继续工作。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;diff-算法&quot;&gt;diff 算法&lt;/h3&gt;

&lt;p&gt;参考：https://juejin.cn/post/6844904165026562056&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;diff 算法是什么？
diff 算法会比较前后虚拟 DOM，从而得到 patches(补丁)，然后与老 Virtual DOM 进行对比，将其应用在需要更新的地方，得到新的 Virtual DOM，在网上有一张非常直观的图可以帮忙参考
&lt;img src=&quot;/assets/images/210509/domDiff.png&quot; alt=&quot;domDiff.png&quot; /&gt;
来解释下这张图：现有一个真实的 DOM，首先会映射为虚拟 DOM，这个时候，我们删除了最后一个 p 节点和 son2 的节点，得到了新的一个虚拟 DOM，新的 vdom 会和旧的 vdom 进行差异对比，得到了 pathes 对象，之后，对旧的真实 dom 进行操作，得到了新的 DOM。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;diff 策略&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;
        &lt;p&gt;Web UI 中 DOM 节点跨层级的移动操作特别少，可以忽略不计。&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;拥有相同类的两个组件将会生成相似的树形结构，拥有不同类的两个组件将会生成不同的树形结构。&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;对于同一层级的一组子节点，它们可以通过唯一 id 进行区分。&lt;/p&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;基于以上三个策略，React 分别对 tree diff、component diff 以及 element diff 进行了算法优化。&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;
        &lt;p&gt;tree diff
基于第一个策略，react 只会对同一层次的节点进行比较，当发现节点不存在时，就会删除整个节点及其子节点，不会再进行比较，这样就只需要遍历一次，就能完成对整个 DOM 树的比较。
如果出现了 DOM 节点的跨层级的移动操作，React diff 会怎样呢？React 只会简单的考虑同层级节点的位置变换，对于不同层级的节点，只有创建和删除操作。&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;component diff
React 对于组件间的比较采取的策略也是简洁高效。
如果是同一类型的组件，按照原策略继续比较虚拟 dom 树；
如果不是，则将该组件判断为 dirty component，从而替换整个组件下的所有子节点；
对于同一类型的组件，有可能其 Virtual DOM 没有任何变化，如果能够确切的知道这点那可以节省大量的 diff 运算的时间，因此 React 允许用户通过 shouldComponentUpdate()判断该组件是否需要进行 diff。&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;element diff
当节点处于同一层级时，React diff 提供了三种节点操作：插入、移动和删除。
插入：新的 component 类型不在老集合里 -&amp;gt; 全新的节点，需要对新节点执行插入操作；
移动：在老集合里有新 component 类型，且 element 是可更新的类型，generateComponentChildren 已调用 receiveComponent，这种情况下 prevChild=nextChild，就需要做移动操作，可以复用以前的 dom 节点；
删除：老的 component 类型，在新集合中也有，但对应的 element 不同则不能直接复用和更新，需要执行删除操作，或者老 component 不在新集合里，也需要执行删除操作。&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;总结：
基于 diff 这样的策略，所以 react 建议我们用添加唯一 key 的方式来进行优化。&lt;/p&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;
</description>
        <pubDate>Sat, 08 May 2021 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2021/05/react-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%99%9A%E6%8B%9Fdom%E5%92%8Cdiff%E7%AE%97%E6%B3%95/</link>
        <guid isPermaLink="true">http://localhost:4000/2021/05/react-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%99%9A%E6%8B%9Fdom%E5%92%8Cdiff%E7%AE%97%E6%B3%95/</guid>
        
        <category>#react,</category>
        
        <category>#react</category>
        
        <category>virtual</category>
        
        <category>dom,</category>
        
        <category>#react</category>
        
        <category>diff算法</category>
        
        
      </item>
    
      <item>
        <title>算法的时间复杂度和空间复杂度</title>
        <description>&lt;h3 id=&quot;前言&quot;&gt;前言&lt;/h3&gt;

&lt;p&gt;如何衡量算法的优劣呢？主要从算法所占用的“时间”和“空间”去衡量。
时间维度：是指执行当前算法所消耗的时间，我们通常用【时间复杂度】来描述
空间维度：是指执行当前算法需要占用多少内存空间，我们通常用【空间复杂度】来描述&lt;/p&gt;

&lt;h3 id=&quot;大-o-复杂度表示法&quot;&gt;大 O 复杂度表示法&lt;/h3&gt;

&lt;p&gt;算法执行的效率。通俗的讲，就是算法代码执行的时间。
简单看个例子：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;var m = 0;
for(i=1; i&amp;lt;=n; ++i)
{
   j = i;
   j++;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;从 CPU 的角度来看，这段代码的每一行都执行着类似的操作：读数据-运算-写数据。尽管每行代码对应的 CPU 执行的个数、执行的时间都不一样，但是，我们这里只是粗略估计，所以可以假设每行代码执行的时间都一样，为 unit_time。在这个假设的基础之上，这段代码的总执行时间是多少呢？
line1 执行需要 1 个 unit_time 时间，line2,line4,line5 都执行的 n 遍，所以需要 n+n+n=3n 个 unit_time 的执行时间。所以这段代码的总执行时间就是：(1+3n)unit_time。
从这个结果可以看出，这个算法的耗时是【 随着 n 的变化而变化 】，因此，我们可以简化的将这个算法的时间复杂度表示为：T(n) = O(n)
为什么可以这么去简化呢，因为大 O 符号表示法并不是用于来真实代表算法的执行时间的，它是【 用来表示代码执行时间的增长变化趋势的 】。
所以上面的例子中，如果 n 无限大的时候，T(n) = time(1+3n)中的常量 1 就没有意义了，倍数 3 也意义不大。因此直接简化为 T(n) = O(n) 就可以了。&lt;/p&gt;

&lt;p&gt;在 大 O 符号表示法中，时间复杂度的公式是： T(n) = O( f(n) )，其中 f(n) 表示每行代码执行次数之和，而 O 表示正比例关系，这个公式的全称是：算法的渐进时间复杂度。&lt;/p&gt;

&lt;h3 id=&quot;时间复杂度&quot;&gt;时间复杂度&lt;/h3&gt;

&lt;p&gt;常见的时间复杂度量级有：&lt;/p&gt;

&lt;p&gt;常数阶 O(1)
对数阶 O(logN)
线性阶 O(n)
线性对数阶 O(nlogN)
平方阶 O(n²)
立方阶 O(n³)
K 次方阶 O(n^k)
指数阶(2^n)
上面从上至下依次的时间复杂度越来越大，执行的效率越来越低。&lt;/p&gt;

&lt;p&gt;选取上面几个来分析：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;常数阶 O(1)
无论执行了多少行，只要是没有循环等复杂结构，那这个代码的时间复杂度就是 O(1)，如：&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;var m = 0;
var n = 1;
var test = m + n;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;

    &lt;p&gt;上述代码在执行的时候，它消耗的时候并不随着某个变量的增长而增长，那么无论这类代码有多长，即使有几万几十万行，都可以用 O(1)来表示它的时间复杂度。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;线性阶 O(n)&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;var m = 1;
for(i=1; i&amp;lt;=n; ++i)
{
 m = i;
}

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;

    &lt;p&gt;这段代码，for 循环里面的代码会执行 n 遍，因此它消耗的时间是随着 n 的变化而变化的，因此这类代码都可以用 O(n)来表示它的时间复杂度。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;对数阶 O(logN)&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;var i = 1;
while(i&amp;lt;n)
{
    i = i * 2;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;

    &lt;p&gt;上面代码中，在 while 循环里，每次都将 i 乘以 2，乘完之后，i 距离 n 越来越近了。假设循环 x 次之后，i 就大于 n 了，此时这个循环就退出了。也就是说，2 的 x 次方等于 n。求出 x=log2(n) 即：log 以 2 为底 n 的对数。也就是说，当循环 log2(n)次以后，这个代码就结束了。因此这个代码的时间复杂度为：O(logn)&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;线性对数阶 O(nlogN)
线性对数阶 O(nlogN) 其实非常容易理解，将时间复杂度为 O(logn)的代码循环 N 遍的话，那么它的时间复杂度就是 n 乘以 O(logN)，也就是了 O(nlogN)。&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;for(var i=0; i&amp;lt;n; i++){
    m = 1
    while(m &amp;lt; n){
        m = m * 2
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;平方阶 O(n²)
把 O(n) 的代码再嵌套循环一遍，它的时间复杂度就是 O(n²)&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;var test = 1;
for(x=0; x&amp;lt;n; x++){
    for(y=0; y&amp;lt;n; y++){
        test = x+y
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;

    &lt;p&gt;如果将其中的一层循环 n 改成 m,那么时间复杂度就是 O(m*n)：&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;var test = 1;
for(x=0; x&amp;lt;m; x++){
    for(y=0; y&amp;lt;n; y++){
        test = x+y
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;空间复杂度&quot;&gt;空间复杂度&lt;/h3&gt;

&lt;p&gt;既然时间复杂度不是用来计算程序具体耗时的，那么空间复杂度也不是用来计算程序实际占用的空间的。
空间复杂度是对一个算法在运行过程中临时占用存储空间大小的一个衡量，同样反映的是一个趋势，用 S(n)来定义。&lt;/p&gt;

&lt;p&gt;空间复杂度比较常用的有：
O(1)、O(n)、O(n²)&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;空间复杂度 O(1)
如果算法执行所需要的临时空间不随着某个变量 n 的大小而变化，即此算法空间复杂度为一个常量，可表示为 O(1)
例如：&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;var i = 0;
var m = 1;
i++;
m++;
var n = m + i;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;

    &lt;p&gt;代码中的 i,m,n 所分配的空间都不随着处理数据变化，因此它的空间复杂度为 S(n) = O(1)&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;空间复杂度 O(n)&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;int[] m = new int[n]
for(i=1; i&amp;lt;=n; ++i)
{
 j = i;
 j++;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;

    &lt;p&gt;这段代码中，line1 new 了一个数组出来，这个数据占用的大小为 n,这段代码的 line2-6, 虽然有循环，但是没有再分配新的空间，因此这段代码的空间复杂度主要看第一行即可。即：S(n) = O(n)&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;function print(n) {
     var i = 0;
     var a = [];
     for (i; i &amp;lt;n; ++i) {
         a[i] = i * i;
     }
     for (i = n-1; i &amp;gt;= 0; --i) {
         console.log(a[i])
     }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;

    &lt;p&gt;这段代码也是，代码中，line2 申请了一个空间存储变量 i，但是它是常量阶的，跟数据规模 n 没有关系，所以我们可以忽略。line3 申请了一个大小为 n 的 int 类型数组，除此之外，剩下的代码都没有占用更多的空间，所以整段代码的空间复杂度就是 O(n)。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;
</description>
        <pubDate>Sat, 08 May 2021 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2021/05/%E7%AE%97%E6%B3%95%E7%9A%84%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%92%8C%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6/</link>
        <guid isPermaLink="true">http://localhost:4000/2021/05/%E7%AE%97%E6%B3%95%E7%9A%84%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%92%8C%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6/</guid>
        
        <category>#时间复杂度,</category>
        
        <category>#空间复杂度</category>
        
        
      </item>
    
      <item>
        <title>解决oninput事件在中文输入法下会取得拼音的值的问题</title>
        <description>&lt;h3 id=&quot;前言&quot;&gt;前言&lt;/h3&gt;

&lt;p&gt;如果直接通过 input 监听输入框输入，它会在键盘按键按下的时候就触发事件，这样就会导致一些问题，比如在 chrome 浏览器中，想输入中文输入不了。
解决方法是，用 compositionstart 和 compositionend.&lt;/p&gt;

&lt;p&gt;注意：chrome 和 safari 浏览器（webkit 内核）跟其他浏览器的执行顺序不同，
chrome 和 safari 是 compositionstart =&amp;gt; 监听 input 事件 =&amp;gt; compositionend,&lt;br /&gt;
其他浏览器是 compositionstart =&amp;gt; compositionend =&amp;gt; 监听 input 事件。
所以，在 compositionend 浏览器里面要判断一下是否是谷歌浏览器。&lt;/p&gt;

&lt;h3 id=&quot;上代码&quot;&gt;上代码&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    // 输入框事件
    const searchInputDom = document.getElementById('search-input');

    // 解决oninput事件在中文输入法下会取得拼音的值的问题
    let isInputZh = false;

    searchInputDom.addEventListener('compositionstart', (e)=&amp;gt; {
        console.log('compositionstart')
        isInputZh = true;
    }, false);

    searchInputDom.addEventListener('compositionend',  (e)=&amp;gt; {
        console.log('compositionend')
        isInputZh = false;

        // 判断是否是webkit内核
        if(!isInputZh &amp;amp;&amp;amp; isWebkit()){
            toSearch(searchInputDom.value)
        }

    }, false);

    searchInputDom.oninput= (e) =&amp;gt; {
      console.log('oninput')
      if(isInputZh) return;
      toSearch(e.target.value)
    };



    // 判断是否是chrome or safari
    function isWebkit(){
        var browser = {
            versions: function() {
                var u = navigator.userAgent, app = navigator.appVersion;
                return {
                    trident: u.indexOf('Trident') &amp;gt; -1, //IE内核
                    presto: u.indexOf('Presto') &amp;gt; -1, //opera内核
                    webKit: u.indexOf('AppleWebKit') &amp;gt; -1, //苹果、谷歌内核
                    gecko: u.indexOf('Gecko') &amp;gt; -1 &amp;amp;&amp;amp; u.indexOf('KHTML') == -1, //火狐内核
                    mobile: !!u.match(/AppleWebKit.*Mobile.*/) || !!u.match(/AppleWebKit/), //是否为移动终端
                    ios: !!u.match(/\(i[^;]+;( U;)? CPU.+Mac OS X/), //ios终端
                    android: u.indexOf('Android') &amp;gt; -1 || u.indexOf('Linux') &amp;gt; -1, //android终端或者uc浏览器
                    iPhone: u.indexOf('iPhone') &amp;gt; -1 || u.indexOf('Mac') &amp;gt; -1, //是否为iPhone或者QQHD浏览器
                    iPad: u.indexOf('iPad') &amp;gt; -1, //是否iPad
                    webApp: u.indexOf('Safari') == -1 //是否web应该程序，没有头部与底部
                };
            }(),
            language: (navigator.browserLanguage || navigator.language).toLowerCase()
        }

        if(browser.versions.webKit){
            return true;
        }

        return false;
    }

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
</description>
        <pubDate>Fri, 07 May 2021 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2021/05/%E8%A7%A3%E5%86%B3oninput%E4%BA%8B%E4%BB%B6%E5%9C%A8%E4%B8%AD%E6%96%87%E8%BE%93%E5%85%A5%E6%B3%95%E4%B8%8B%E4%BC%9A%E5%8F%96%E5%BE%97%E6%8B%BC%E9%9F%B3%E7%9A%84%E5%80%BC%E7%9A%84%E9%97%AE%E9%A2%98/</link>
        <guid isPermaLink="true">http://localhost:4000/2021/05/%E8%A7%A3%E5%86%B3oninput%E4%BA%8B%E4%BB%B6%E5%9C%A8%E4%B8%AD%E6%96%87%E8%BE%93%E5%85%A5%E6%B3%95%E4%B8%8B%E4%BC%9A%E5%8F%96%E5%BE%97%E6%8B%BC%E9%9F%B3%E7%9A%84%E5%80%BC%E7%9A%84%E9%97%AE%E9%A2%98/</guid>
        
        <category>#input,</category>
        
        <category>#oninput事件,</category>
        
        <category>#中文输入法,</category>
        
        <category>#浏览器兼容性</category>
        
        
      </item>
    
      <item>
        <title>vue中input的blur影响下拉框中click事件</title>
        <description>&lt;h3 id=&quot;问题描述&quot;&gt;问题描述:&lt;/h3&gt;

&lt;p&gt;存在如下一段代码：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;lt;input ref=&quot;input&quot; class=&quot;search-box&quot; placeholder=&quot;请输入要搜索的内容&quot; v-model=&quot;keyWords&quot; @input=&quot;search()&quot; @focus=&quot;focusSearch()&quot; @blur=&quot;onBlur()&quot;/&amp;gt;

&amp;lt;div class=&quot;result-list&quot; v-if=&quot;showComplete&quot;&amp;gt;
    &amp;lt;div class=&quot;result-item&quot; v-if=&quot;searchResultList.length === 0&quot;&amp;gt;没有找到对应内容&amp;lt;/div&amp;gt;
    &amp;lt;div class=&quot;result-item&quot; v-for=&quot;r in searchResultList&quot; :key=&quot;r.id&quot; @click=&quot;toSearch([r])&quot;&amp;gt;&amp;lt;/div&amp;gt;
&amp;lt;/div&amp;gt;

onBlur(){
    console.log('blur')
    this.showComplete = false
}
toSearch(nodes){
    console.log('click')
    // do sth...
    this.$nextTick(()=&amp;gt;{
        this.keyWords = '';
    })
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;输入框输入关键字搜索，选择下拉框里匹配的某一条数据后，click 无法执行。主要原因是。blur 的优先级比 click 高，先触发了 blur 事件 showComplete = false,下拉列表注销，click 无法执行。&lt;/p&gt;

&lt;h3 id=&quot;解决办法&quot;&gt;解决办法&lt;/h3&gt;

&lt;ol&gt;
  &lt;li&gt;解决办法一：blur 执行的函数可以加个定时器，在 200ms 后执行&lt;/li&gt;
&lt;/ol&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;onBlur(){
      console.log('blur')
      setTimeout(()=&amp;gt;{
        this.showComplete = false
      },200)
},
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ol&gt;
  &lt;li&gt;解决办法二：将 click 换成优先级更高的 mousedown，将优先于 blur 执行&lt;/li&gt;
&lt;/ol&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;lt;div class=&quot;result-item&quot; v-for=&quot;r in searchResultList&quot; :key=&quot;r.id&quot; @mousedown=&quot;toSearch([r])&quot;&amp;gt;&amp;lt;/div&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
</description>
        <pubDate>Fri, 07 May 2021 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2021/05/vue%E4%B8%ADinput%E7%9A%84blur%E5%BD%B1%E5%93%8D%E4%B8%8B%E6%8B%89%E6%A1%86%E4%B8%ADclick%E4%BA%8B%E4%BB%B6/</link>
        <guid isPermaLink="true">http://localhost:4000/2021/05/vue%E4%B8%ADinput%E7%9A%84blur%E5%BD%B1%E5%93%8D%E4%B8%8B%E6%8B%89%E6%A1%86%E4%B8%ADclick%E4%BA%8B%E4%BB%B6/</guid>
        
        <category>#vue，</category>
        
        <category>#input,</category>
        
        <category>#blur,</category>
        
        <category>#click</category>
        
        
      </item>
    
      <item>
        <title>json tree形数据查找复合条件的json tree数据</title>
        <description>&lt;h3 id=&quot;需求描述&quot;&gt;需求描述&lt;/h3&gt;

&lt;p&gt;存在一个 json tree 形数据：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;var treeData = [
    {
        id: 'root',
        name: '食物',
        children: [
            {
                id: '1',
                name: '水果',
                children: [
                    {
                        id: '1-1',
                        name: '水果-苹果',
                        children: []
                    },
                    {
                        id: '1-2',
                        name: '香蕉',
                        children: []
                    }
                ]
            },
            {
                id: '2',
                name: '主食',
                children: [
                    {
                        id: '2-1',
                        name: '主食-米饭',
                        children: []
                    },
                    {
                        id: '2-2',
                        name: '面条',
                        children: []
                    },
                    {
                        id: '2-3',
                        name: '米线',
                        children: []
                    }
                ]
            },
            {
                id: '3',
                name: '零食',
                children: [
                    {
                        id: '3-1',
                        name: '瓜子',
                        children: []
                    },
                    {
                        id: '3-2',
                        name: '花生',
                        children: []
                    },
                    {
                        id: '3-3',
                        name: '蚕豆',
                        children: []
                    }
                ]
            }
        ]
    }
]
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;输入框搜索关键词，如：“水果”，一旦发现某一层级的 name 匹配上了关键词，则返回这一层级以及他的所有子元素。
返回的数据应该如下：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;var searchResult = [
    {
        id: 'root',
        name: '食物',
        children: [
            {
                id: '1',
                name: '水果',
                children: [
                    {
                        id: '1-1',
                        name: '水果-苹果',
                        children: []
                    },
                    {
                        id: '1-2',
                        name: '香蕉',
                        children: []
                    }
                ]
            }
    }
]
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;算法如下：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    // tree search
    handleTreeData(treeData, searchValue) {
      if (!treeData || treeData.length === 0) {
        return [];
      }
      const array = [];
      for (let i = 0; i &amp;lt; treeData.length; i += 1) {
        const nodeName = treeData[i].name.toLowerCase()
        const searchName = searchValue.toLowerCase()
        if (this.handleTreeData(treeData[i].children, searchValue).length &amp;gt; 0 || nodeName.includes(searchName)) {
          let obj = {
            ...treeData[i]
          }
          if(!nodeName.includes(searchName)){
            // 父节点name不包含searchVal,则继续查找。否则，子节点不用查找，把父节点和父节点的children直接返回
            obj.children = this.handleTreeData(treeData[i].children, searchValue)
          }
          array.push(obj)
        }
      }
      return array;
    }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
</description>
        <pubDate>Fri, 07 May 2021 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2021/05/json-tree%E5%BD%A2%E6%95%B0%E6%8D%AE%E6%9F%A5%E6%89%BE%E5%A4%8D%E5%90%88%E6%9D%A1%E4%BB%B6%E7%9A%84json-tree%E6%95%B0%E6%8D%AE/</link>
        <guid isPermaLink="true">http://localhost:4000/2021/05/json-tree%E5%BD%A2%E6%95%B0%E6%8D%AE%E6%9F%A5%E6%89%BE%E5%A4%8D%E5%90%88%E6%9D%A1%E4%BB%B6%E7%9A%84json-tree%E6%95%B0%E6%8D%AE/</guid>
        
        <category>#input,</category>
        
        <category>#oninput事件,</category>
        
        <category>#中文输入法,</category>
        
        <category>#浏览器兼容性</category>
        
        
      </item>
    
      <item>
        <title>谈谈vue-router</title>
        <description>&lt;h3 id=&quot;vue-router-对不同模式的实现大致是这样的&quot;&gt;vue-router 对不同模式的实现大致是这样的：&lt;/h3&gt;

&lt;ol&gt;
  &lt;li&gt;首先根据 mode 来确定所选的模式，如果当前环境不支持 history 模式，会强制切换到 hash 模式；&lt;/li&gt;
  &lt;li&gt;如果当前环境不是浏览器环境，会切换到 abstract 模式下。然后再根据不同模式来生成不同的 history 操作对象。&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;new-vuerouter-过程&quot;&gt;new VueRouter 过程&lt;/h3&gt;

&lt;ol&gt;
  &lt;li&gt;init 方法内的 app 变量便是存储的当前的 vue 实例的 this。&lt;/li&gt;
  &lt;li&gt;将 app 存入数组 apps 中。通过 this.app 判断是实例否已经被初始化。&lt;/li&gt;
  &lt;li&gt;通过 history 来确定不同路由的切换动作 history.transitionTo。&lt;/li&gt;
  &lt;li&gt;通过 history.listen 来注册路由变化的响应回调。&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;hash-和-history-的区别&quot;&gt;hash 和 history 的区别&lt;/h3&gt;

&lt;ol&gt;
  &lt;li&gt;最明显的是在显示上，hash 模式的 URL 中会夹杂着#号，而 history 没有。&lt;/li&gt;
  &lt;li&gt;Vue 底层对它们的实现方式不同。hash 模式是依靠 onhashchange 事件(监听 location.hash 的改变)，而 history 模式（popstate）是主要是依靠的 HTML5 history 中新增的两个方法，pushState()可以改变 url 地址且不会发送请求，replaceState()可以读取历史记录栈，还可以对浏览器记录进行修改。&lt;/li&gt;
  &lt;li&gt;当真正需要通过 URL 向后端发送 HTTP 请求的时候，比如常见的用户手动输入 URL 后回车，或者是刷新(重启)浏览器，这时候 history 模式需要后端的支持。因为 history 模式下，前端的 URL 必须和实际向后端发送请求的 URL 一致，例如有一个 URL 是带有路径 path 的(例如www.lindaidai.wang/blogs/id)，如果后端没有对这个路径做处理的话，就会返回404错误。所以需要后端增加一个覆盖所有情况的候选资源，一般会配合前端给出的一个404页面。&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;vue-history-配置&quot;&gt;vue history 配置&lt;/h3&gt;

&lt;p&gt;vue history 需要 nginx 或者其他方式配置一下才可正确访问，否则路由跳转之后刷新一下便会出现 404。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;vue history 模式 部署在服务器端的 nginx 配置 (非根目录)配置如下：&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;server {

        listen      443 ;

        server_name  m;

        root  html/mobile;

        location / {

            index  index.html index.htm;

            try_files $uri $uri/ /index.html;

        }

    }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;路由配置：&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;const router=new VueRouter({
  mode: 'history',
  routes
})
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
</description>
        <pubDate>Mon, 12 Apr 2021 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2021/04/%E8%B0%88%E8%B0%88vueRouter/</link>
        <guid isPermaLink="true">http://localhost:4000/2021/04/%E8%B0%88%E8%B0%88vueRouter/</guid>
        
        <category>#vue,</category>
        
        <category>#vue-router,</category>
        
        <category>#hash,</category>
        
        <category>#history</category>
        
        
      </item>
    
      <item>
        <title>vue 核心角色</title>
        <description>&lt;h3 id=&quot;vue-响应式过程的原理&quot;&gt;vue 响应式过程的原理：&lt;/h3&gt;

&lt;p&gt;当创建 Vue 实例时,vue 会遍历 data 选项的属性,利用 Object.defineProperty 为属性添加 getter 和 setter 对数据的读取进行劫持（getter 用来依赖收集,setter 用来派发更新）,并且在内部追踪依赖,在属性被访问和修改时通知变化。&lt;/p&gt;

&lt;p&gt;每个组件实例会有相应的 watcher 实例,会在组件渲染的过程中记录依赖的所有数据属性（进行依赖收集,还有 computed watcher,user watcher 实例）,之后依赖项被改动时,setter 逻辑会通知依赖与此 data 的 watcher 实例重新计算（派发更新）,从而使它关联的组件重新渲染。&lt;/p&gt;

&lt;p&gt;总结就是: vue.js 采用数据劫持结合发布-订阅模式,通过 Object.defineproperty 来劫持各个属性的 setter,getter,在数据变动时发布消息给订阅者,触发响应的监听回调&lt;/p&gt;

&lt;h3 id=&quot;vue-核心角色是下面几个&quot;&gt;vue 核心角色是下面几个：&lt;/h3&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;Observer（监听器）：给对象添加 getter 和 setter，用于依赖搜集和派发更新。不仅是一个数据监听器，也是发布者；&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Watcher（订阅者）：observer 把数据转发给了真正的订阅者——watcher 对象。watcher 接收到新的数据后，会去更新视图。watcher 实例分为渲染 watcher(render watcher), computed watcher, 侦听器 user watcher。维护了一个 deps（用于收集依赖）的实例数组。二次依赖收集时，cleanupDeps 在每次添加完新的订阅，会移除掉旧的订阅的 deps；&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;compile（编译器）：MVVM 框架特有的角色，负责对每个节点元素指令进行扫描和解析，指令的数据初始化、订阅者的创建这些“杂活”也归它管；&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Dep：用于收集当前响应式对象的依赖关系，每个响应式对象都有一个 Dep 实例（里边 subs 是 Watcher 实例数组），数据变更触发 setter 逻辑时，通过 dep.notify()(遍历 subs，调用每个 Watcher 的 update()方法)通知各个 Watcher。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;核心代码&quot;&gt;核心代码&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;实现 observer&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;// 遍历对象
function observer(target) {
  // target是对象，则遍历
  if (target &amp;amp;&amp;amp; typeof target === 'object') {
    Object.keys(target).forEach(key =&amp;gt; {
      defineReactive(target, key, target[key])
    })
  }
}

// 用defineProperty监听当前属性
function defineReactive(target, key, val) {
  const dep = new Dep()
  // 递归
  observer(val)
  Object.defineProperty(target, key, {
    // 可枚举
    enumerable: true,
    // 不可配置
    configurable: false,
    get: function() {
      return val
    },
    set: function(value) {
      console.log(val, value)
      val = value
    }
  })
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;实现 dep 订阅者&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;class Dep {
  constructor() {
    // 初始化订阅队列
    this.subs = []
  }
  // 增加订阅
  addSub(sub) {
    this.subs.push(sub)
  }
  // 通知订阅者
  notify() {
    this.subs.forEach(sub =&amp;gt; {
      sub.update()
    })
  }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;订阅者 Dep 里的 subs 数组是 Watcher 实例。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;实现 Watcher 类&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;class Watcher {
  constructor() {}
  update() {
    // 更新视图
  }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;改写 defineReactive 中的 setter 方法，在监听器里去通知订阅者了:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;// 用defineProperty监听当前属性
function defineReactive(target, key, val) {
  const dep = new Dep()
  // 递归
  observer(val)
  Object.defineProperty(target, key, {
    // 可枚举
    enumerable: true,
    // 不可配置
    configurable: false,
    get: function() {
      return val
    },
    set: function(value) {
      console.log(val, value)
      dep.notify()
    }
  })
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
</description>
        <pubDate>Mon, 12 Apr 2021 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2021/04/vue%E6%A0%B8%E5%BF%83%E8%A7%92%E8%89%B2/</link>
        <guid isPermaLink="true">http://localhost:4000/2021/04/vue%E6%A0%B8%E5%BF%83%E8%A7%92%E8%89%B2/</guid>
        
        <category>#vue核心角色</category>
        
        
      </item>
    
      <item>
        <title>vue和react diff 算法对比</title>
        <description>&lt;h3 id=&quot;react-diff-算法&quot;&gt;react diff 算法&lt;/h3&gt;

&lt;p&gt;当调用 React 的 render()方法时，会创建一棵由 React 元素组成的树。在下一次 State 或 Props 更新时，相同的 render()方法会返回一棵不同的树。React 会应用 Diffing 算法来高效的比较两棵树，算法过程如下：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;当根节点为【不同类型】的元素时，React 会拆卸原有的树，销毁对应的 DOM 节点和关联的 State、卸载子组件，最后再创建新的树。&lt;/li&gt;
  &lt;li&gt;当比对两个【相同类型的 DOM 元素】时，会保留 DOM 节点，【仅比对变更的属性】。&lt;/li&gt;
  &lt;li&gt;当比对两个【相同类型的组件元素】时，组件实例保持不变，【更新该组件实例的 Props】。&lt;/li&gt;
  &lt;li&gt;当递归 DOM 节点的子元素时，React 会同时遍历两个子元素的列表，比对相同位置的元素，性能比较低效。&lt;/li&gt;
  &lt;li&gt;在给子元素添加唯一标识的 key 属性后，就能只比对变更了 key 属性的元素。&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;vue20-diff-算法&quot;&gt;vue2.0 diff 算法&lt;/h3&gt;

&lt;ol&gt;
  &lt;li&gt;先同级比较再比较子节点&lt;/li&gt;
  &lt;li&gt;先判断一方有子节点和一方没有子节点的情况。如果新的一方有子节点，旧的一方没有，相当于新的子节点替代了原来没有的节点；同理，如果新的一方没有子节点，旧的一方有，相当于要把老的节点删除。&lt;/li&gt;
  &lt;li&gt;再来比较都有子节点的情况，这里是 diff 的核心。首先会通过判断两个节点的 key、tag、isComment、data 同时定义或不定义以及当标签类型为 input 的时候 type 相不相同来确定两个节点是不是相同的节点，如果不是的话就将新节点替换旧节点。&lt;/li&gt;
  &lt;li&gt;如果是相同节点的话才会进入到 patchVNode 阶段。在这个阶段核心是采用【双指针】的算法，同时从新旧节点的两端进行比较，在这个过程中，会用到模版编译时的静态标记配合 key 来跳过对比静态节点，如果不是的话再进行其它的比较。&lt;/li&gt;
&lt;/ol&gt;

&lt;ul&gt;
  &lt;li&gt;** 缺点：因为采用的是同级比较，所以如果发现本级的节点不同的话就会将新节点直接替换旧节点，不会再去比较其下的子节点是否有相同 **&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;vue2vue3-和-react-比较&quot;&gt;vue2、vue3 和 react 比较&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;vue2 和 vue3.x:
Vue3.x 借鉴了 ivi 算法和 inferno 算法。
它在创建 VNode 的时候就确定了其类型，以及在 mount/patch 的过程中采用位运算来判断一个 VNode 的类型，在这个基础之上再配合核心的 Diff 算法，使得性能上较 Vue2.x 有了提升。&lt;/li&gt;
  &lt;li&gt;vue 和 react:
共同点是：都是用同层比较，不同点是：vue 使用双指针比较，react 是用 key 集合级比较。&lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Mon, 12 Apr 2021 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2021/04/vue%E5%92%8Creact-diff-%E7%AE%97%E6%B3%95%E5%AF%B9%E6%AF%94/</link>
        <guid isPermaLink="true">http://localhost:4000/2021/04/vue%E5%92%8Creact-diff-%E7%AE%97%E6%B3%95%E5%AF%B9%E6%AF%94/</guid>
        
        <category>#vue2.0,</category>
        
        <category>#vue3.0,</category>
        
        <category>#react</category>
        
        
      </item>
    
      <item>
        <title>vue computed 属性为什么能够在依赖改变的时候，自己发生变化</title>
        <description>&lt;h3 id=&quot;vue-computed-属性为什么能够在依赖改变的时候自己发生变化&quot;&gt;Vue computed 属性为什么能够在依赖改变的时候，自己发生变化？&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/0412/1.png&quot; alt=&quot;1.png&quot; /&gt;
computed 和 watch 公用一个 Watcher 类，在 computed 的情况下有一个 deps 。 Vue 在二次收集依赖时用 cleanupDeps 在每次添加完新的订阅，会移除掉旧的订阅。&lt;/p&gt;

&lt;h3 id=&quot;收集依赖&quot;&gt;收集依赖&lt;/h3&gt;

&lt;ol&gt;
  &lt;li&gt;initState 时，对 computed 属性初始化时，触发 computed Watcher 依赖收集&lt;/li&gt;
  &lt;li&gt;initState 时，对 watch 属性初始化时，触发 user Watcher 依赖收集&lt;/li&gt;
  &lt;li&gt;render()的过程，触发 render watcher 依赖收集&lt;/li&gt;
  &lt;li&gt;re-render 时，vm.render()再次执行，会移除 subs 的订阅，重新赋值&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;查看&lt;a href=&quot;https://zhuanlan.zhihu.com/p/45081605&quot;&gt;‘收集依赖’&lt;/a&gt;更详细的解释。&lt;/p&gt;
</description>
        <pubDate>Mon, 12 Apr 2021 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2021/04/vue-computed-%E5%B1%9E%E6%80%A7%E4%B8%BA%E4%BB%80%E4%B9%88%E8%83%BD%E5%A4%9F%E5%9C%A8%E4%BE%9D%E8%B5%96%E6%94%B9%E5%8F%98%E7%9A%84%E6%97%B6%E5%80%99-%E8%87%AA%E5%B7%B1%E5%8F%91%E7%94%9F%E5%8F%98%E5%8C%96/</link>
        <guid isPermaLink="true">http://localhost:4000/2021/04/vue-computed-%E5%B1%9E%E6%80%A7%E4%B8%BA%E4%BB%80%E4%B9%88%E8%83%BD%E5%A4%9F%E5%9C%A8%E4%BE%9D%E8%B5%96%E6%94%B9%E5%8F%98%E7%9A%84%E6%97%B6%E5%80%99-%E8%87%AA%E5%B7%B1%E5%8F%91%E7%94%9F%E5%8F%98%E5%8C%96/</guid>
        
        <category>#vue,</category>
        
        <category>#computed属性</category>
        
        
      </item>
    
  </channel>
</rss>
