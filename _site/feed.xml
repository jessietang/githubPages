<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>唐静</title>
    <description>2年RN，3年前端。</description>
    <link>http://localhost:4000/</link>
    <atom:link href="http://localhost:4000/feed.xml" rel="self" type="application/rss+xml"/>
    <pubDate>Fri, 07 May 2021 11:26:19 +0800</pubDate>
    <lastBuildDate>Fri, 07 May 2021 11:26:19 +0800</lastBuildDate>
    <generator>Jekyll v3.8.5</generator>
    
      <item>
        <title>2021-05-07-解决oninput事件在中文输入法下会取得拼音的值的问题</title>
        <description>&lt;h3 id=&quot;前言&quot;&gt;前言&lt;/h3&gt;

&lt;p&gt;如果直接通过 input 监听输入框输入，它会在键盘按键按下的时候就触发事件，这样就会导致一些问题，比如在 chrome 浏览器中，想输入中文输入不了。
解决方法是，用 compositionstart 和 compositionend.&lt;/p&gt;

&lt;p&gt;注意：chrome 和 safari 浏览器（webkit 内核）跟其他浏览器的执行顺序不同，
chrome 和 safari 是 compositionstart =&amp;gt; 监听 input 事件 =&amp;gt; compositionend,&lt;br /&gt;
其他浏览器是 compositionstart =&amp;gt; compositionend =&amp;gt; 监听 input 事件。
所以，在 compositionend 浏览器里面要判断一下是否是谷歌浏览器。&lt;/p&gt;

&lt;h3 id=&quot;上代码&quot;&gt;上代码&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    // 输入框事件
    const searchInputDom = document.getElementById('search-input');

    // 解决oninput事件在中文输入法下会取得拼音的值的问题
    let isInputZh = false;

    searchInputDom.addEventListener('compositionstart', (e)=&amp;gt; {
        console.log('compositionstart')
        isInputZh = true;
    }, false);

    searchInputDom.addEventListener('compositionend',  (e)=&amp;gt; {
        console.log('compositionend')
        isInputZh = false;

        // 判断是否是webkit内核
        if(!isInputZh &amp;amp;&amp;amp; isWebkit()){
            toSearch(searchInputDom.value)
        }

    }, false);

    searchInputDom.oninput= (e) =&amp;gt; {
      console.log('oninput')
      if(isInputZh) return;
      toSearch(e.target.value)
    };



    // 判断是否是chrome or safari
    function isWebkit(){
        var browser = {
            versions: function() {
                var u = navigator.userAgent, app = navigator.appVersion;
                return {
                    trident: u.indexOf('Trident') &amp;gt; -1, //IE内核
                    presto: u.indexOf('Presto') &amp;gt; -1, //opera内核
                    webKit: u.indexOf('AppleWebKit') &amp;gt; -1, //苹果、谷歌内核
                    gecko: u.indexOf('Gecko') &amp;gt; -1 &amp;amp;&amp;amp; u.indexOf('KHTML') == -1, //火狐内核
                    mobile: !!u.match(/AppleWebKit.*Mobile.*/) || !!u.match(/AppleWebKit/), //是否为移动终端
                    ios: !!u.match(/\(i[^;]+;( U;)? CPU.+Mac OS X/), //ios终端
                    android: u.indexOf('Android') &amp;gt; -1 || u.indexOf('Linux') &amp;gt; -1, //android终端或者uc浏览器
                    iPhone: u.indexOf('iPhone') &amp;gt; -1 || u.indexOf('Mac') &amp;gt; -1, //是否为iPhone或者QQHD浏览器
                    iPad: u.indexOf('iPad') &amp;gt; -1, //是否iPad
                    webApp: u.indexOf('Safari') == -1 //是否web应该程序，没有头部与底部
                };
            }(),
            language: (navigator.browserLanguage || navigator.language).toLowerCase()
        }

        if(browser.versions.webKit){
            return true;
        }

        return false;
    }

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
</description>
        <pubDate>Fri, 07 May 2021 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2021/05/%E8%A7%A3%E5%86%B3oninput%E4%BA%8B%E4%BB%B6%E5%9C%A8%E4%B8%AD%E6%96%87%E8%BE%93%E5%85%A5%E6%B3%95%E4%B8%8B%E4%BC%9A%E5%8F%96%E5%BE%97%E6%8B%BC%E9%9F%B3%E7%9A%84%E5%80%BC%E7%9A%84%E9%97%AE%E9%A2%98/</link>
        <guid isPermaLink="true">http://localhost:4000/2021/05/%E8%A7%A3%E5%86%B3oninput%E4%BA%8B%E4%BB%B6%E5%9C%A8%E4%B8%AD%E6%96%87%E8%BE%93%E5%85%A5%E6%B3%95%E4%B8%8B%E4%BC%9A%E5%8F%96%E5%BE%97%E6%8B%BC%E9%9F%B3%E7%9A%84%E5%80%BC%E7%9A%84%E9%97%AE%E9%A2%98/</guid>
        
        <category>#input,</category>
        
        <category>#oninput事件,</category>
        
        <category>#中文输入法,</category>
        
        <category>#浏览器兼容性</category>
        
        
      </item>
    
      <item>
        <title>2021-05-07-vue中input的blur影响下拉框中click事件</title>
        <description>&lt;h3 id=&quot;问题描述&quot;&gt;问题描述:&lt;/h3&gt;

&lt;p&gt;存在如下一段代码：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;lt;input ref=&quot;input&quot; class=&quot;search-box&quot; placeholder=&quot;请输入要搜索的内容&quot; v-model=&quot;keyWords&quot; @input=&quot;search()&quot; @focus=&quot;focusSearch()&quot; @blur=&quot;onBlur()&quot;/&amp;gt;

&amp;lt;div class=&quot;result-list&quot; v-if=&quot;showComplete&quot;&amp;gt;
    &amp;lt;div class=&quot;result-item&quot; v-if=&quot;searchResultList.length === 0&quot;&amp;gt;没有找到对应内容&amp;lt;/div&amp;gt;
    &amp;lt;div class=&quot;result-item&quot; v-for=&quot;r in searchResultList&quot; :key=&quot;r.id&quot; @click=&quot;toSearch([r])&quot;&amp;gt;&amp;lt;/div&amp;gt;
&amp;lt;/div&amp;gt;

onBlur(){
    console.log('blur')
    this.showComplete = false
}
toSearch(nodes){
    console.log('click')
    // do sth...
    this.$nextTick(()=&amp;gt;{
        this.keyWords = '';
    })
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;输入框输入关键字搜索，选择下拉框里匹配的某一条数据后，click 无法执行。主要原因是。blur 的优先级比 click 高，先触发了 blur 事件 showComplete = false,下拉列表注销，click 无法执行。&lt;/p&gt;

&lt;h3 id=&quot;解决办法&quot;&gt;解决办法&lt;/h3&gt;

&lt;ol&gt;
  &lt;li&gt;解决办法一：blur 执行的函数可以加个定时器，在 200ms 后执行&lt;/li&gt;
&lt;/ol&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;onBlur(){
      console.log('blur')
      setTimeout(()=&amp;gt;{
        this.showComplete = false
      },200)
},
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ol&gt;
  &lt;li&gt;解决办法二：将 click 换成优先级更高的 mousedown，将优先于 blur 执行&lt;/li&gt;
&lt;/ol&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;lt;div class=&quot;result-item&quot; v-for=&quot;r in searchResultList&quot; :key=&quot;r.id&quot; @mousedown=&quot;toSearch([r])&quot;&amp;gt;&amp;lt;/div&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
</description>
        <pubDate>Fri, 07 May 2021 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2021/05/vue%E4%B8%ADinput%E7%9A%84blur%E5%BD%B1%E5%93%8D%E4%B8%8B%E6%8B%89%E6%A1%86%E4%B8%ADclick%E4%BA%8B%E4%BB%B6/</link>
        <guid isPermaLink="true">http://localhost:4000/2021/05/vue%E4%B8%ADinput%E7%9A%84blur%E5%BD%B1%E5%93%8D%E4%B8%8B%E6%8B%89%E6%A1%86%E4%B8%ADclick%E4%BA%8B%E4%BB%B6/</guid>
        
        <category>#vue，</category>
        
        <category>#input,</category>
        
        <category>#blur,</category>
        
        <category>#click</category>
        
        
      </item>
    
      <item>
        <title>2021-05-07-json tree形数据查找复合条件的json tree数据</title>
        <description>&lt;h3 id=&quot;需求描述&quot;&gt;需求描述&lt;/h3&gt;

&lt;p&gt;存在一个 json tree 形数据：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;var treeData = [
    {
        id: 'root',
        name: '食物',
        children: [
            {
                id: '1',
                name: '水果',
                children: [
                    {
                        id: '1-1',
                        name: '水果-苹果',
                        children: []
                    },
                    {
                        id: '1-2',
                        name: '香蕉',
                        children: []
                    }
                ]
            },
            {
                id: '2',
                name: '主食',
                children: [
                    {
                        id: '2-1',
                        name: '主食-米饭',
                        children: []
                    },
                    {
                        id: '2-2',
                        name: '面条',
                        children: []
                    },
                    {
                        id: '2-3',
                        name: '米线',
                        children: []
                    }
                ]
            },
            {
                id: '3',
                name: '零食',
                children: [
                    {
                        id: '3-1',
                        name: '瓜子',
                        children: []
                    },
                    {
                        id: '3-2',
                        name: '花生',
                        children: []
                    },
                    {
                        id: '3-3',
                        name: '蚕豆',
                        children: []
                    }
                ]
            }
        ]
    }
]
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;输入框搜索关键词，如：“水果”，一旦发现某一层级的 name 匹配上了关键词，则返回这一层级以及他的所有子元素。
返回的数据应该如下：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;var searchResult = [
    {
        id: 'root',
        name: '食物',
        children: [
            {
                id: '1',
                name: '水果',
                children: [
                    {
                        id: '1-1',
                        name: '水果-苹果',
                        children: []
                    },
                    {
                        id: '1-2',
                        name: '香蕉',
                        children: []
                    }
                ]
            }
    }
]
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;算法如下：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    // tree search
    handleTreeData(treeData, searchValue) {
      if (!treeData || treeData.length === 0) {
        return [];
      }
      const array = [];
      for (let i = 0; i &amp;lt; treeData.length; i += 1) {
        const nodeName = treeData[i].name.toLowerCase()
        const searchName = searchValue.toLowerCase()
        if (this.handleTreeData(treeData[i].children, searchValue).length &amp;gt; 0 || nodeName.includes(searchName)) {
          let obj = {
            ...treeData[i]
          }
          if(!nodeName.includes(searchName)){
            // 父节点name不包含searchVal,则继续查找。否则，子节点不用查找，把父节点和父节点的children直接返回
            obj.children = this.handleTreeData(treeData[i].children, searchValue)
          }
          array.push(obj)
        }
      }
      return array;
    }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
</description>
        <pubDate>Fri, 07 May 2021 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2021/05/json-tree%E5%BD%A2%E6%95%B0%E6%8D%AE%E6%9F%A5%E6%89%BE%E5%A4%8D%E5%90%88%E6%9D%A1%E4%BB%B6%E7%9A%84json-tree%E6%95%B0%E6%8D%AE/</link>
        <guid isPermaLink="true">http://localhost:4000/2021/05/json-tree%E5%BD%A2%E6%95%B0%E6%8D%AE%E6%9F%A5%E6%89%BE%E5%A4%8D%E5%90%88%E6%9D%A1%E4%BB%B6%E7%9A%84json-tree%E6%95%B0%E6%8D%AE/</guid>
        
        <category>#input,</category>
        
        <category>#oninput事件,</category>
        
        <category>#中文输入法,</category>
        
        <category>#浏览器兼容性</category>
        
        
      </item>
    
      <item>
        <title>2021-04-12-谈谈vue-router</title>
        <description>&lt;h3 id=&quot;vue-router-对不同模式的实现大致是这样的&quot;&gt;vue-router 对不同模式的实现大致是这样的：&lt;/h3&gt;

&lt;ol&gt;
  &lt;li&gt;首先根据 mode 来确定所选的模式，如果当前环境不支持 history 模式，会强制切换到 hash 模式；&lt;/li&gt;
  &lt;li&gt;如果当前环境不是浏览器环境，会切换到 abstract 模式下。然后再根据不同模式来生成不同的 history 操作对象。&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;new-vuerouter-过程&quot;&gt;new VueRouter 过程&lt;/h3&gt;

&lt;ol&gt;
  &lt;li&gt;init 方法内的 app 变量便是存储的当前的 vue 实例的 this。&lt;/li&gt;
  &lt;li&gt;将 app 存入数组 apps 中。通过 this.app 判断是实例否已经被初始化。&lt;/li&gt;
  &lt;li&gt;通过 history 来确定不同路由的切换动作 history.transitionTo。&lt;/li&gt;
  &lt;li&gt;通过 history.listen 来注册路由变化的响应回调。&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;hash-和-history-的区别&quot;&gt;hash 和 history 的区别&lt;/h3&gt;

&lt;ol&gt;
  &lt;li&gt;最明显的是在显示上，hash 模式的 URL 中会夹杂着#号，而 history 没有。&lt;/li&gt;
  &lt;li&gt;Vue 底层对它们的实现方式不同。hash 模式是依靠 onhashchange 事件(监听 location.hash 的改变)，而 history 模式（popstate）是主要是依靠的 HTML5 history 中新增的两个方法，pushState()可以改变 url 地址且不会发送请求，replaceState()可以读取历史记录栈，还可以对浏览器记录进行修改。&lt;/li&gt;
  &lt;li&gt;当真正需要通过 URL 向后端发送 HTTP 请求的时候，比如常见的用户手动输入 URL 后回车，或者是刷新(重启)浏览器，这时候 history 模式需要后端的支持。因为 history 模式下，前端的 URL 必须和实际向后端发送请求的 URL 一致，例如有一个 URL 是带有路径 path 的(例如www.lindaidai.wang/blogs/id)，如果后端没有对这个路径做处理的话，就会返回404错误。所以需要后端增加一个覆盖所有情况的候选资源，一般会配合前端给出的一个404页面。&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;vue-history-配置&quot;&gt;vue history 配置&lt;/h3&gt;

&lt;p&gt;vue history 需要 nginx 或者其他方式配置一下才可正确访问，否则路由跳转之后刷新一下便会出现 404。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;vue history 模式 部署在服务器端的 nginx 配置 (非根目录)配置如下：&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;server {

        listen      443 ;

        server_name  m;

        root  html/mobile;

        location / {

            index  index.html index.htm;

            try_files $uri $uri/ /index.html;

        }

    }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;路由配置：&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;const router=new VueRouter({
  mode: 'history',
  routes
})
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
</description>
        <pubDate>Mon, 12 Apr 2021 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2021/04/%E8%B0%88%E8%B0%88vueRouter/</link>
        <guid isPermaLink="true">http://localhost:4000/2021/04/%E8%B0%88%E8%B0%88vueRouter/</guid>
        
        <category>#vue,</category>
        
        <category>#vue-router,</category>
        
        <category>#hash,</category>
        
        <category>#history</category>
        
        
      </item>
    
      <item>
        <title>2021-04-12-vue 核心角色</title>
        <description>&lt;h3 id=&quot;vue-响应式过程的原理&quot;&gt;vue 响应式过程的原理：&lt;/h3&gt;

&lt;p&gt;当创建 Vue 实例时,vue 会遍历 data 选项的属性,利用 Object.defineProperty 为属性添加 getter 和 setter 对数据的读取进行劫持（getter 用来依赖收集,setter 用来派发更新）,并且在内部追踪依赖,在属性被访问和修改时通知变化。&lt;/p&gt;

&lt;p&gt;每个组件实例会有相应的 watcher 实例,会在组件渲染的过程中记录依赖的所有数据属性（进行依赖收集,还有 computed watcher,user watcher 实例）,之后依赖项被改动时,setter 逻辑会通知依赖与此 data 的 watcher 实例重新计算（派发更新）,从而使它关联的组件重新渲染。&lt;/p&gt;

&lt;p&gt;总结就是: vue.js 采用数据劫持结合发布-订阅模式,通过 Object.defineproperty 来劫持各个属性的 setter,getter,在数据变动时发布消息给订阅者,触发响应的监听回调&lt;/p&gt;

&lt;h3 id=&quot;vue-核心角色是下面几个&quot;&gt;vue 核心角色是下面几个：&lt;/h3&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;Observer（监听器）：给对象添加 getter 和 setter，用于依赖搜集和派发更新。不仅是一个数据监听器，也是发布者；&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Watcher（订阅者）：observer 把数据转发给了真正的订阅者——watcher 对象。watcher 接收到新的数据后，会去更新视图。watcher 实例分为渲染 watcher(render watcher), computed watcher, 侦听器 user watcher。维护了一个 deps（用于收集依赖）的实例数组。二次依赖收集时，cleanupDeps 在每次添加完新的订阅，会移除掉旧的订阅的 deps；&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;compile（编译器）：MVVM 框架特有的角色，负责对每个节点元素指令进行扫描和解析，指令的数据初始化、订阅者的创建这些“杂活”也归它管；&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Dep：用于收集当前响应式对象的依赖关系，每个响应式对象都有一个 Dep 实例（里边 subs 是 Watcher 实例数组），数据变更触发 setter 逻辑时，通过 dep.notify()(遍历 subs，调用每个 Watcher 的 update()方法)通知各个 Watcher。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;核心代码&quot;&gt;核心代码&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;实现 observer&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;// 遍历对象
function observer(target) {
  // target是对象，则遍历
  if (target &amp;amp;&amp;amp; typeof target === 'object') {
    Object.keys(target).forEach(key =&amp;gt; {
      defineReactive(target, key, target[key])
    })
  }
}

// 用defineProperty监听当前属性
function defineReactive(target, key, val) {
  const dep = new Dep()
  // 递归
  observer(val)
  Object.defineProperty(target, key, {
    // 可枚举
    enumerable: true,
    // 不可配置
    configurable: false,
    get: function() {
      return val
    },
    set: function(value) {
      console.log(val, value)
      val = value
    }
  })
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;实现 dep 订阅者&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;class Dep {
  constructor() {
    // 初始化订阅队列
    this.subs = []
  }
  // 增加订阅
  addSub(sub) {
    this.subs.push(sub)
  }
  // 通知订阅者
  notify() {
    this.subs.forEach(sub =&amp;gt; {
      sub.update()
    })
  }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;订阅者 Dep 里的 subs 数组是 Watcher 实例。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;实现 Watcher 类&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;class Watcher {
  constructor() {}
  update() {
    // 更新视图
  }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;改写 defineReactive 中的 setter 方法，在监听器里去通知订阅者了:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;// 用defineProperty监听当前属性
function defineReactive(target, key, val) {
  const dep = new Dep()
  // 递归
  observer(val)
  Object.defineProperty(target, key, {
    // 可枚举
    enumerable: true,
    // 不可配置
    configurable: false,
    get: function() {
      return val
    },
    set: function(value) {
      console.log(val, value)
      dep.notify()
    }
  })
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
</description>
        <pubDate>Mon, 12 Apr 2021 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2021/04/vue%E6%A0%B8%E5%BF%83%E8%A7%92%E8%89%B2/</link>
        <guid isPermaLink="true">http://localhost:4000/2021/04/vue%E6%A0%B8%E5%BF%83%E8%A7%92%E8%89%B2/</guid>
        
        <category>#vue核心角色</category>
        
        
      </item>
    
      <item>
        <title>2021-04-12-vue和react diff 算法对比</title>
        <description>&lt;h3 id=&quot;react-diff-算法&quot;&gt;react diff 算法&lt;/h3&gt;

&lt;p&gt;当调用 React 的 render()方法时，会创建一棵由 React 元素组成的树。在下一次 State 或 Props 更新时，相同的 render()方法会返回一棵不同的树。React 会应用 Diffing 算法来高效的比较两棵树，算法过程如下：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;当根节点为【不同类型】的元素时，React 会拆卸原有的树，销毁对应的 DOM 节点和关联的 State、卸载子组件，最后再创建新的树。&lt;/li&gt;
  &lt;li&gt;当比对两个【相同类型的 DOM 元素】时，会保留 DOM 节点，【仅比对变更的属性】。&lt;/li&gt;
  &lt;li&gt;当比对两个【相同类型的组件元素】时，组件实例保持不变，【更新该组件实例的 Props】。&lt;/li&gt;
  &lt;li&gt;当递归 DOM 节点的子元素时，React 会同时遍历两个子元素的列表，比对相同位置的元素，性能比较低效。&lt;/li&gt;
  &lt;li&gt;在给子元素添加唯一标识的 key 属性后，就能只比对变更了 key 属性的元素。&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;vue20-diff-算法&quot;&gt;vue2.0 diff 算法&lt;/h3&gt;

&lt;ol&gt;
  &lt;li&gt;先同级比较再比较子节点&lt;/li&gt;
  &lt;li&gt;先判断一方有子节点和一方没有子节点的情况。如果新的一方有子节点，旧的一方没有，相当于新的子节点替代了原来没有的节点；同理，如果新的一方没有子节点，旧的一方有，相当于要把老的节点删除。&lt;/li&gt;
  &lt;li&gt;再来比较都有子节点的情况，这里是 diff 的核心。首先会通过判断两个节点的 key、tag、isComment、data 同时定义或不定义以及当标签类型为 input 的时候 type 相不相同来确定两个节点是不是相同的节点，如果不是的话就将新节点替换旧节点。&lt;/li&gt;
  &lt;li&gt;如果是相同节点的话才会进入到 patchVNode 阶段。在这个阶段核心是采用【双指针】的算法，同时从新旧节点的两端进行比较，在这个过程中，会用到模版编译时的静态标记配合 key 来跳过对比静态节点，如果不是的话再进行其它的比较。&lt;/li&gt;
&lt;/ol&gt;

&lt;ul&gt;
  &lt;li&gt;** 缺点：因为采用的是同级比较，所以如果发现本级的节点不同的话就会将新节点直接替换旧节点，不会再去比较其下的子节点是否有相同 **&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;vue2vue3-和-react-比较&quot;&gt;vue2、vue3 和 react 比较&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;vue2 和 vue3.x:
Vue3.x 借鉴了 ivi 算法和 inferno 算法。
它在创建 VNode 的时候就确定了其类型，以及在 mount/patch 的过程中采用位运算来判断一个 VNode 的类型，在这个基础之上再配合核心的 Diff 算法，使得性能上较 Vue2.x 有了提升。&lt;/li&gt;
  &lt;li&gt;vue 和 react:
共同点是：都是用同层比较，不同点是：vue 使用双指针比较，react 是用 key 集合级比较。&lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Mon, 12 Apr 2021 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2021/04/vue%E5%92%8Creact-diff-%E7%AE%97%E6%B3%95%E5%AF%B9%E6%AF%94/</link>
        <guid isPermaLink="true">http://localhost:4000/2021/04/vue%E5%92%8Creact-diff-%E7%AE%97%E6%B3%95%E5%AF%B9%E6%AF%94/</guid>
        
        <category>#vue2.0,</category>
        
        <category>#vue3.0,</category>
        
        <category>#react</category>
        
        
      </item>
    
      <item>
        <title>2021-04-12-vue computed 属性为什么能够在依赖改变的时候，自己发生变化</title>
        <description>&lt;h3 id=&quot;vue-computed-属性为什么能够在依赖改变的时候自己发生变化&quot;&gt;Vue computed 属性为什么能够在依赖改变的时候，自己发生变化？&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/0412/1.png&quot; alt=&quot;1.png&quot; /&gt;
computed 和 watch 公用一个 Watcher 类，在 computed 的情况下有一个 deps 。 Vue 在二次收集依赖时用 cleanupDeps 在每次添加完新的订阅，会移除掉旧的订阅。&lt;/p&gt;

&lt;h3 id=&quot;收集依赖&quot;&gt;收集依赖&lt;/h3&gt;

&lt;ol&gt;
  &lt;li&gt;initState 时，对 computed 属性初始化时，触发 computed Watcher 依赖收集&lt;/li&gt;
  &lt;li&gt;initState 时，对 watch 属性初始化时，触发 user Watcher 依赖收集&lt;/li&gt;
  &lt;li&gt;render()的过程，触发 render watcher 依赖收集&lt;/li&gt;
  &lt;li&gt;re-render 时，vm.render()再次执行，会移除 subs 的订阅，重新赋值&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;查看&lt;a href=&quot;https://zhuanlan.zhihu.com/p/45081605&quot;&gt;‘收集依赖’&lt;/a&gt;更详细的解释。&lt;/p&gt;
</description>
        <pubDate>Mon, 12 Apr 2021 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2021/04/vue-computed-%E5%B1%9E%E6%80%A7%E4%B8%BA%E4%BB%80%E4%B9%88%E8%83%BD%E5%A4%9F%E5%9C%A8%E4%BE%9D%E8%B5%96%E6%94%B9%E5%8F%98%E7%9A%84%E6%97%B6%E5%80%99-%E8%87%AA%E5%B7%B1%E5%8F%91%E7%94%9F%E5%8F%98%E5%8C%96/</link>
        <guid isPermaLink="true">http://localhost:4000/2021/04/vue-computed-%E5%B1%9E%E6%80%A7%E4%B8%BA%E4%BB%80%E4%B9%88%E8%83%BD%E5%A4%9F%E5%9C%A8%E4%BE%9D%E8%B5%96%E6%94%B9%E5%8F%98%E7%9A%84%E6%97%B6%E5%80%99-%E8%87%AA%E5%B7%B1%E5%8F%91%E7%94%9F%E5%8F%98%E5%8C%96/</guid>
        
        <category>#vue,</category>
        
        <category>#computed属性</category>
        
        
      </item>
    
      <item>
        <title>2021-04-08-一些电子书籍链接记录</title>
        <description>&lt;p&gt;一些电子书籍链接记录:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;a href=&quot;https://pan.baidu.com/s/1VZ2anKyMgm3gTkeYktpkaQ&quot;&gt;代码大全 2 中文版(完整清晰版).pdf&lt;/a&gt; 密码: lhpv&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://pan.baidu.com/s/1Thn91nCt23ymspWKyO7_qQ&quot;&gt;javascript 设计模式与开发实战.pdf（曾探）&lt;/a&gt; 密码: pd49&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://pan.baidu.com/s/1sdU6Uv2Nvppp2YEv8zUZzw&quot;&gt;深入 react 技术栈.pdf&lt;/a&gt; 密码: 7o6b&lt;/li&gt;
&lt;/ol&gt;
</description>
        <pubDate>Tue, 06 Apr 2021 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2021/04/%E7%94%B5%E5%AD%90%E4%B9%A6%E7%B1%8D%E5%BD%95/</link>
        <guid isPermaLink="true">http://localhost:4000/2021/04/%E7%94%B5%E5%AD%90%E4%B9%A6%E7%B1%8D%E5%BD%95/</guid>
        
        <category>#电子书籍</category>
        
        
      </item>
    
      <item>
        <title>2021-04-08-Object.create()使用及探究</title>
        <description>&lt;p&gt;前言：在看 js 设计模式的时候，有提到：JavaScript 没有提供传统面向对象语言中的类式继承，而是通过原型委托的方式来实现对象
与对象之间的继承。
委托是一种利用 Object.create 与对象方式实现的 js 类多态方式。&lt;/p&gt;

&lt;p&gt;例如，我们最近正在做的轻量化引擎里面就有这样的应用：OrbitControls.prototype = Object.create( EventDispatcher.prototype );&lt;/p&gt;

&lt;h3 id=&quot;objectcreateproto-propertiesobject&quot;&gt;Object.create(proto, [propertiesObject])&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;参数：proto : 必须。表示新建对象的原型对象，即该参数会被赋值到目标对象(即新对象，或说是最后返回的对象)的原型上。该参数可以是&lt;code class=&quot;highlighter-rouge&quot;&gt;null&lt;/code&gt;， &lt;code class=&quot;highlighter-rouge&quot;&gt;对象&lt;/code&gt;， 函数的&lt;code class=&quot;highlighter-rouge&quot;&gt;prototype属性&lt;/code&gt; （创建空的对象时需传 null , 否则会抛出&lt;code class=&quot;highlighter-rouge&quot;&gt;TypeError&lt;/code&gt;异常）。&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;propertiesObject : 可选。 添加到新创建对象的可枚举属性（即其自身的属性，而不是原型链上的枚举属性）对象的属性描述符以及相应的属性名称。这些属性对应&lt;a href=&quot;https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperties&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Object.defineProperties()&lt;/code&gt;&lt;/a&gt;的第二个参数。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;先使用一波
&lt;img src=&quot;/assets/images/0408/1.png&quot; alt=&quot;1.png&quot; /&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;给对象原型添加属性和方法&lt;/li&gt;
&lt;/ul&gt;

&lt;ol&gt;
  &lt;li&gt;使用 Object.create()给对象原型添加属性和方法：&lt;/li&gt;
&lt;/ol&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;var proto = {
	x:1,
	y:2,
	showNum(){}
}
var o = Object.create(proto)
console.log(o) // 结果见截图
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/0408/2.png&quot; alt=&quot;2.png&quot; /&gt;&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;如果不是使用 Object.create()方法，我们是如何给对象原型添加属性和方法的呢？&lt;/li&gt;
&lt;/ol&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;// 创建一个构造函数或者类
var People = function(){}
People.prototype.x = 1
People.prototype.t = 2
People.prototype.showNum = function(){}
// 通过构造函数创建实例
var p = new People()
console.log(p.__proto__ === People.prototype) // true
console.log(p) //结果见截图
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/0408/3.png&quot; alt=&quot;3.png&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;再看下面一段代码（原型属性的继承）：&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;var triangle = {a: 1, b: 2, c: 3};

function ColoredTriangle() {
  this.color = 'red';
}

// ColoredTriangle.prototype = triangle;  // ColoredTriangle.prototype.constructor === ColoredTriangle // false

Object.assign(ColoredTriangle.prototype, triangle) // ColoredTriangle.prototype.constructor === ColoredTriangle // true

var c = new ColoredTriangle();
console.log(c) // 这里打印出c可以看看结构。其中color属性在实例上，而其他的在原型上。如下图：
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/0408/4.png&quot; alt=&quot;4.png&quot; /&gt;&lt;/p&gt;

&lt;p&gt;再来拷贝一个实例 c3:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;var c3 = Object.assign({}, c)
console.log(c3.color) // red
console.log(c3.a) // undefined
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/0408/5.png&quot; alt=&quot;5.png&quot; /&gt;&lt;/p&gt;

&lt;p&gt;因为 Object.assign 是不能拷贝到继承或原型上的方法的。&lt;/p&gt;

&lt;p&gt;所以 c3 没有 a 这个属性。那要怎么样才能拷贝原型上的方法呢？见下：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;var c2 = Object.create(Object.getPrototypeOf(c), Object.getOwnPropertyDescriptors(c));

console.log(c2) // 结果见下图
console.log(c2.color); // red
console.log(c2.a); // 1
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/0408/6.png&quot; alt=&quot;6.png&quot; /&gt;&lt;/p&gt;

&lt;p&gt;可以把 Object.create()的参数理解为：第一个参数是放在新对象的原型上的，第二个参数是放在新对象的实例上的。
所以上面例子 Object.getPrototypeOf() 得到的是 c 对象的原型，然后作为第一个参数，所以会在新对象 c2 的原型上。
Object.getOwnPropertyDescriptors() 得到是 c 对象自身的可枚举属性，作为第二个参数，放在 c2 的实例上。
为什么说推荐这个方法呢？因为 Object.assign() 方法不能正确拷贝 get ，set 属性。&lt;/p&gt;

&lt;p&gt;上面实现 原型属性拷贝 中的两种方法中用到了 &lt;code class=&quot;highlighter-rouge&quot;&gt;Object.getOwnPropertyDescriptors&lt;/code&gt; 、&lt;code class=&quot;highlighter-rouge&quot;&gt;Object.assing()&lt;/code&gt; 、&lt;code class=&quot;highlighter-rouge&quot;&gt;Object.create&lt;/code&gt;、&lt;code class=&quot;highlighter-rouge&quot;&gt;Object.getPrototypeOf()&lt;/code&gt;方法，通常这几种方法都有一起结合使用。&lt;/p&gt;
</description>
        <pubDate>Tue, 06 Apr 2021 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2021/04/Object.create()%E4%BD%BF%E7%94%A8%E4%B8%8E%E6%8E%A2%E7%A9%B6/</link>
        <guid isPermaLink="true">http://localhost:4000/2021/04/Object.create()%E4%BD%BF%E7%94%A8%E4%B8%8E%E6%8E%A2%E7%A9%B6/</guid>
        
        <category>#Object.create(),</category>
        
        <category>#js设计模式（代理模式）</category>
        
        
      </item>
    
      <item>
        <title>2021-04-06-iphone各机型屏幕尺寸（包含最新iphone12）</title>
        <description>&lt;p&gt;前言：更新 iphone 各机型屏幕尺寸列表（包含最新 iphone12）&lt;/p&gt;

&lt;h3 id=&quot;iphone-各机型屏幕尺寸如下所示&quot;&gt;iphone 各机型屏幕尺寸如下所示&lt;/h3&gt;

&lt;table&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;手机设备型号&lt;/td&gt;
      &lt;td&gt;屏幕尺寸&lt;/td&gt;
      &lt;td&gt;分辨率点数（pt）&lt;/td&gt;
      &lt;td&gt;屏幕显示模式&lt;/td&gt;
      &lt;td&gt;分辨率像素（px）&lt;/td&gt;
      &lt;td&gt;屏幕比例&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;iPhone SE&lt;/td&gt;
      &lt;td&gt;4.0 吋&lt;/td&gt;
      &lt;td&gt;320x568&lt;/td&gt;
      &lt;td&gt;@2x&lt;/td&gt;
      &lt;td&gt;640x1136&lt;/td&gt;
      &lt;td&gt;16:9&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;iPhone 6/6s/7/8/SE 2&lt;/td&gt;
      &lt;td&gt;4.7 吋&lt;/td&gt;
      &lt;td&gt;375x667&lt;/td&gt;
      &lt;td&gt;@2x&lt;/td&gt;
      &lt;td&gt;750x1334&lt;/td&gt;
      &lt;td&gt;16:9&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;iPhone 6p/7p/8p&lt;/td&gt;
      &lt;td&gt;5.5 吋&lt;/td&gt;
      &lt;td&gt;414x736&lt;/td&gt;
      &lt;td&gt;@3x&lt;/td&gt;
      &lt;td&gt;1242x2208&lt;/td&gt;
      &lt;td&gt;16:9&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;iPhone XR/11&lt;/td&gt;
      &lt;td&gt;6.1 吋&lt;/td&gt;
      &lt;td&gt;414x896&lt;/td&gt;
      &lt;td&gt;@2x&lt;/td&gt;
      &lt;td&gt;828x1792&lt;/td&gt;
      &lt;td&gt;19.5:9&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;iPhone X/XS/11 Pro&lt;/td&gt;
      &lt;td&gt;5.8 吋&lt;/td&gt;
      &lt;td&gt;375x812&lt;/td&gt;
      &lt;td&gt;@3x&lt;/td&gt;
      &lt;td&gt;1125x2436&lt;/td&gt;
      &lt;td&gt;19.5:9&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;iPhone XS Max/11 Pro Max&lt;/td&gt;
      &lt;td&gt;6.5 吋&lt;/td&gt;
      &lt;td&gt;414x896&lt;/td&gt;
      &lt;td&gt;@3x&lt;/td&gt;
      &lt;td&gt;1242x2688&lt;/td&gt;
      &lt;td&gt;19.5:9&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;iPhone 12 mini&lt;/td&gt;
      &lt;td&gt;5.4 吋&lt;/td&gt;
      &lt;td&gt;360x780&lt;/td&gt;
      &lt;td&gt;@3x&lt;/td&gt;
      &lt;td&gt;1080x2340&lt;/td&gt;
      &lt;td&gt;19.5:9&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;iPhone 12/12 Pro&lt;/td&gt;
      &lt;td&gt;6.1 吋&lt;/td&gt;
      &lt;td&gt;390x844&lt;/td&gt;
      &lt;td&gt;@3x&lt;/td&gt;
      &lt;td&gt;1170x2532&lt;/td&gt;
      &lt;td&gt;19.5:9&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;iPhone 12 Pro Max&lt;/td&gt;
      &lt;td&gt;6.7 吋&lt;/td&gt;
      &lt;td&gt;428x926&lt;/td&gt;
      &lt;td&gt;@3x&lt;/td&gt;
      &lt;td&gt;1284x2778&lt;/td&gt;
      &lt;td&gt;19.5:9&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;
</description>
        <pubDate>Tue, 06 Apr 2021 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2021/04/iphone%E5%90%84%E6%9C%BA%E5%9E%8B%E5%B1%8F%E5%B9%95%E5%B0%BA%E5%AF%B8-%E5%8C%85%E5%90%AB%E6%9C%80%E6%96%B0iphone12/</link>
        <guid isPermaLink="true">http://localhost:4000/2021/04/iphone%E5%90%84%E6%9C%BA%E5%9E%8B%E5%B1%8F%E5%B9%95%E5%B0%BA%E5%AF%B8-%E5%8C%85%E5%90%AB%E6%9C%80%E6%96%B0iphone12/</guid>
        
        <category>#ios,</category>
        
        <category>#iphone,</category>
        
        <category>#屏幕尺寸</category>
        
        
      </item>
    
  </channel>
</rss>
