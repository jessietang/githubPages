<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>唐静</title>
    <description>2年RN，3年前端。</description>
    <link>http://localhost:4000/</link>
    <atom:link href="http://localhost:4000/feed.xml" rel="self" type="application/rss+xml"/>
    <pubDate>Mon, 24 May 2021 14:56:03 +0800</pubDate>
    <lastBuildDate>Mon, 24 May 2021 14:56:03 +0800</lastBuildDate>
    <generator>Jekyll v3.8.5</generator>
    
      <item>
        <title>node快速切换版本、版本升级和降级</title>
        <description>&lt;h3 id=&quot;为什么要涉及版本切换&quot;&gt;为什么要涉及版本切换&lt;/h3&gt;

&lt;p&gt;在某天把电脑安装的 node 版本升级到了最新版本（v14.17.0）。后面在某个 app tets 项目里面，用的是 expo-cli 脚手架构建的项目。执行启动命令&lt;code class=&quot;highlighter-rouge&quot;&gt;expo start --ios&lt;/code&gt;的时候，报了一个错：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;ERROR: Node.js version 14.17.0 is no longer supported.

expo-cli supports following Node.js versions:
* &amp;gt;=10.13.0 &amp;lt;11.0.0 (Active LTS)
* &amp;gt;=12.0.0 &amp;lt;13.0.0 (Active LTS)
* &amp;gt;=13.0.0 &amp;lt;14.0.0 (Current Release)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;从报错可以看到，只支持 14.0.0 一下的 node 版本。
所以需要把 node 版本降回来，但是我又想把最新版本留着。这个时候就需要一个可以快速切换 node 版本的工具了。
以下来源于网络，整理记录一番：&lt;/p&gt;

&lt;h4 id=&quot;node-版本管理模块-n&quot;&gt;node 版本管理模块 n&lt;/h4&gt;

&lt;ol&gt;
  &lt;li&gt;安装 node 版本管理模块 n
mac:&lt;/li&gt;
&lt;/ol&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;sudo npm install n -g
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;windows:
管理员模式打开 cmd&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;npm install n -g
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;如遇到下面的报错：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;unsupported platform for n@7.2.2: wanted {&quot;os&quot;: &quot;!win32&quot;, &quot;arch&quot;: &quot;any&quot;} &amp;lt;current: {&quot;os&quot;: &quot;win32&quot;, &quot;arch&quot;: &quot;x64&quot;}&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;我的 windows 的确是 win64, 但是在操作时还是报这个错了。解决办法：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;npm install n -g --force
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;下面的步骤根据需求安装（接下来我都列举 mac 的安装方式，sudo 是 mac 下输入密码验证身份的命令，因此 windows 用户应该是以管理员身份运行命令行工具）&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;安装稳定版本&lt;/li&gt;
&lt;/ol&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;sudo n stable
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ol&gt;
  &lt;li&gt;安装最新版本&lt;/li&gt;
&lt;/ol&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;sudo n latest
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ol&gt;
  &lt;li&gt;安装指定版本， 如 12.0.0 版本&lt;/li&gt;
&lt;/ol&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;sudo n 12.0.0
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ol&gt;
  &lt;li&gt;查看当前安装了哪些版本&lt;/li&gt;
&lt;/ol&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;n
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;执行查看安装了哪些版本命令之后，会出现你安装的列表，通过上下箭头进行选择切换。&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;删除版本&lt;/li&gt;
&lt;/ol&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;sudo n rm 版本号
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
</description>
        <pubDate>Mon, 24 May 2021 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2021/05/node%E5%BF%AB%E9%80%9F%E5%88%87%E6%8D%A2%E7%89%88%E6%9C%AC-%E7%89%88%E6%9C%AC%E5%8D%87%E7%BA%A7%E5%92%8C%E9%99%8D%E7%BA%A7/</link>
        <guid isPermaLink="true">http://localhost:4000/2021/05/node%E5%BF%AB%E9%80%9F%E5%88%87%E6%8D%A2%E7%89%88%E6%9C%AC-%E7%89%88%E6%9C%AC%E5%8D%87%E7%BA%A7%E5%92%8C%E9%99%8D%E7%BA%A7/</guid>
        
        <category>#node,</category>
        
        <category>#node版本切换</category>
        
        
      </item>
    
      <item>
        <title>jsdoc的使用</title>
        <description>&lt;h3 id=&quot;需要一个工具javascript-api-文档生成器&quot;&gt;需要一个工具—javascript API 文档生成器&lt;/h3&gt;

&lt;p&gt;我们在开发完成之后，需要写一份 js api 说明文档。手动去写，太麻烦了，而且，如果改动了 js 代码或者注释之类的，需要同时更新 api 文档，比较麻烦。
所以，我们可以使用&lt;a href=&quot;http://shouce.jb51.net/jsdoc/&quot;&gt;jsdoc&lt;/a&gt;这个工具来进行文档的转换。&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;用 conf.json 配置 jsdoc
要自定义 JSDoc 的行为，可以使用 JSON 格式的配置文件格式化 JSDoc，使用-c 选项，例如： jsdoc -c /path/to/conf.json。&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;{
 &quot;opts&quot;: {
     &quot;recurse&quot;: true
 },
 &quot;tags&quot;: {
     &quot;allowUnknownTags&quot;: true,
     &quot;dictionaries&quot;: [
         &quot;jsdoc&quot;,
         &quot;closure&quot;
     ]
 },
 &quot;source&quot;: {
     &quot;include&quot;: [
         &quot;src/demo/Test.js&quot;,
         &quot;src/demo/funcs/views/&quot;,
         &quot;src/demo/funcs/models/&quot;
     ],
     &quot;includePattern&quot;: &quot;.+\\.js(doc)?$&quot;,
     &quot;excludePattern&quot;: &quot;(^|\\/|\\\\)_&quot;
 },
 &quot;plugins&quot;: [],
 &quot;templates&quot;: {
     &quot;cleverLinks&quot;: false,
     &quot;monospaceLinks&quot;: false,
     &quot;default&quot;: {
         &quot;includeDate&quot;: false,
         &quot;outputSourceFiles&quot;: false,
         &quot;layoutFile&quot;: &quot;jsdoc/template/layout.tmpl&quot;
     }
 }
}

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;使用自定义模板 layout.tmpl
这里为了方便， 我直接从 github jsdoc 源码里找到了一个 layout.tmpl 原来的模板, 如下（我修改了引入的 js 文件和 css 文件的路径，要跟执行&lt;code class=&quot;highlighter-rouge&quot;&gt;jsdoc -c ./jsdoc/path/to/conf.json -r&lt;/code&gt;之后生产的文件里面的这些文件匹配，最开始就是没看到这里路径的不同，所以自定义模板一直没起作用）：&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;cp&quot;&gt;&amp;lt;!DOCTYPE html&amp;gt;&lt;/span&gt;
&lt;span class=&quot;nt&quot;&gt;&amp;lt;html&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;lang=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;en&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;gt;&lt;/span&gt;
&lt;span class=&quot;nt&quot;&gt;&amp;lt;head&amp;gt;&lt;/span&gt;
   &lt;span class=&quot;nt&quot;&gt;&amp;lt;meta&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;charset=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;utf-8&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;gt;&lt;/span&gt;
   &lt;span class=&quot;nt&quot;&gt;&amp;lt;title&amp;gt;&lt;/span&gt;JSDoc: &lt;span class=&quot;cp&quot;&gt;&amp;lt;?js= title ?&amp;gt;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;lt;/title&amp;gt;&lt;/span&gt;

   &lt;span class=&quot;nt&quot;&gt;&amp;lt;script &lt;/span&gt;&lt;span class=&quot;na&quot;&gt;src=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;./scripts/prettify/prettify.js&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;&amp;lt;/script&amp;gt;&lt;/span&gt;
   &lt;span class=&quot;nt&quot;&gt;&amp;lt;script &lt;/span&gt;&lt;span class=&quot;na&quot;&gt;src=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;./scripts/prettify/lang-css.js&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;&amp;lt;/script&amp;gt;&lt;/span&gt;
   &lt;span class=&quot;c&quot;&gt;&amp;lt;!--[if lt IE 9]&amp;gt;
   &amp;lt;script src=&quot;//html5shiv.googlecode.com/svn/trunk/html5.js&quot;&amp;gt;&amp;lt;/script&amp;gt;
   &amp;lt;![endif]--&amp;gt;&lt;/span&gt;
   &lt;span class=&quot;nt&quot;&gt;&amp;lt;link&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;type=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;text/css&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;rel=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;stylesheet&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;href=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;./styles/prettify-tomorrow.css&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;gt;&lt;/span&gt;
   &lt;span class=&quot;nt&quot;&gt;&amp;lt;link&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;type=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;text/css&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;rel=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;stylesheet&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;href=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;./styles/jsdoc-default.css&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;gt;&lt;/span&gt;
   &lt;span class=&quot;nt&quot;&gt;&amp;lt;style&amp;gt;&lt;/span&gt;
   &lt;span class=&quot;nt&quot;&gt;section&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
       &lt;span class=&quot;nl&quot;&gt;border-bottom&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;none&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
   &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
   &lt;span class=&quot;nt&quot;&gt;nav&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;h2&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
       &lt;span class=&quot;nl&quot;&gt;display&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;none&lt;/span&gt;&lt;span class=&quot;cp&quot;&gt;!important&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
   &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
   &lt;span class=&quot;nt&quot;&gt;&amp;lt;/style&amp;gt;&lt;/span&gt;
&lt;span class=&quot;nt&quot;&gt;&amp;lt;/head&amp;gt;&lt;/span&gt;

&lt;span class=&quot;nt&quot;&gt;&amp;lt;body&amp;gt;&lt;/span&gt;

&lt;span class=&quot;nt&quot;&gt;&amp;lt;div&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;id=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;main&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;gt;&lt;/span&gt;

   &lt;span class=&quot;nt&quot;&gt;&amp;lt;h1&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;class=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;page-title&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;cp&quot;&gt;&amp;lt;?js= title ?&amp;gt;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;lt;/h1&amp;gt;&lt;/span&gt;

   &lt;span class=&quot;cp&quot;&gt;&amp;lt;?js= content ?&amp;gt;&lt;/span&gt;
&lt;span class=&quot;nt&quot;&gt;&amp;lt;/div&amp;gt;&lt;/span&gt;

&lt;span class=&quot;nt&quot;&gt;&amp;lt;nav&amp;gt;&lt;/span&gt;
   &lt;span class=&quot;cp&quot;&gt;&amp;lt;?js= this.nav ?&amp;gt;&lt;/span&gt;
&lt;span class=&quot;nt&quot;&gt;&amp;lt;/nav&amp;gt;&lt;/span&gt;

&lt;span class=&quot;nt&quot;&gt;&amp;lt;br&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;class=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;clear&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;gt;&lt;/span&gt;

&lt;span class=&quot;nt&quot;&gt;&amp;lt;footer&amp;gt;&lt;/span&gt;
   &lt;span class=&quot;cp&quot;&gt;&amp;lt;?js if(env.conf.templates &amp;amp;&amp;amp; env.conf.templates.default &amp;amp;&amp;amp; env.conf.templates.default.includeDate !== false) { ?&amp;gt;&lt;/span&gt; on &lt;span class=&quot;cp&quot;&gt;&amp;lt;?js= (new Date()) ?&amp;gt;&amp;lt;?js } ?&amp;gt;&lt;/span&gt;
&lt;span class=&quot;nt&quot;&gt;&amp;lt;/footer&amp;gt;&lt;/span&gt;

&lt;span class=&quot;nt&quot;&gt;&amp;lt;script&amp;gt;&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;prettyPrint&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;&amp;lt;/script&amp;gt;&lt;/span&gt;
&lt;span class=&quot;nt&quot;&gt;&amp;lt;script &lt;/span&gt;&lt;span class=&quot;na&quot;&gt;src=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;./scripts/linenumber.js&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;&amp;lt;/script&amp;gt;&lt;/span&gt;
&lt;span class=&quot;nt&quot;&gt;&amp;lt;/body&amp;gt;&lt;/span&gt;
&lt;span class=&quot;nt&quot;&gt;&amp;lt;/html&amp;gt;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;执行&lt;code class=&quot;highlighter-rouge&quot;&gt;jsdoc -c ./jsdoc/path/to/conf.json -r&lt;/code&gt;命令，会生成一个 out 文件夹，里面的各个 html 就是转换结果，把 out 文件夹下面的东西拷贝到需要使用的地方即可。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;
</description>
        <pubDate>Mon, 17 May 2021 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2021/05/jsdoc%E7%9A%84%E4%BD%BF%E7%94%A8/</link>
        <guid isPermaLink="true">http://localhost:4000/2021/05/jsdoc%E7%9A%84%E4%BD%BF%E7%94%A8/</guid>
        
        <category>#javascript,</category>
        
        <category>#js注释转api文档</category>
        
        
      </item>
    
      <item>
        <title>手写promise实现</title>
        <description>&lt;h3 id=&quot;实现代码如下&quot;&gt;实现代码如下：&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;class MyPromise{
    constructor(executor) {
        this.status = &quot;pending&quot;;     // 初始化状态为pending
        this.value = undefined;      // 初始化返回的成功的结果或者失败的原因
        this.resolveArr = [];        // 初始化then中成功的方法
        this.rejectArr = [];         // 初始化then中失败的方法


        // 定义change方法，因为我们发现好像resolve和reject方法共同的地方还挺多
        let change = (status, value) =&amp;gt; {
            if(this.status !== &quot;pending&quot;) return;  // 状态一旦改变，就不会再变
            this.status = status;
            this.value = value;

            // 根据状态判断要执行成功的方法或失败的方法
            let fnArr = status === &quot;resolved&quot; ? this.resolveArr : this.rejectArr;

            // fnArr中的方法依次执行
            fnArr.forEach(item =&amp;gt; {
                if(typeof item !== &quot;function&quot;) return;
                item(this. value);
            })
        }
        // 这里是resolve方法，成功后执行，将状态改变为resolved，并且将结果返回
        let resolve = result =&amp;gt; {
            // 如果数组中有值，则立即改变状态
            if(this.resolveArr.length &amp;gt; 0) {
                change(&quot;resolved&quot;, result)
            }
            // 如果没值，则延后改变状态
            let timer = setTimeout(_ =&amp;gt; {
                change(&quot;resolved&quot;, result)
                clearTimeout(timer);
            }, 0)
        }

        // 这里是reject方法，异常时执行，状态改为rejected，并且将失败的原因返回
        let reject = reason =&amp;gt; {
        // 如果数组中有值，则立即改变状态
            if(this.rejectArr.length &amp;gt; 0) {
                change(&quot;rejected&quot;, reason);
            }
            // 如果没值，则延后改变状态
            let timer = setTimeout(_ =&amp;gt; {
                change(&quot;rejected&quot;, reason);
                clearTimeout(timer);
            }, 0)
        }

        // try、catch捕获异常，如果错误，执行reject方法
        try {
            executor(resolve, reject)
        } catch(err) {
            reject(err)
        }
    }

    then(resolveFn, rejectFn) {
    // 如果传入的两个参数不是函数，则直接执行返回结果

        if(typeof resolveFn !== &quot;function&quot;) {
            resolveFn = result =&amp;gt; {
                return result;
            }
        }

        if(typeof rejectFn !== &quot;function&quot;) {
            rejectFn = reason =&amp;gt; {
                return MyPromise.reject(reason);
            }
        }

        return new MyPromise((resolve, reject) =&amp;gt; {
            this.resolveArr.push(result =&amp;gt; {
                try {
                    let x = resolveFn(result);  // 获取执行成功方法返回的结果

                    // 如果x是一个promise实例，则继续调用then方法 ==&amp;gt; then链的实现
                    if(x instanceof MyPromise) {
                        x.then(resolve, reject)
                        return;
                    }

                    // 不是promise实例，直接执行成功的方法
                    resolve(x);
                } catch(err) {
                    reject(err)
                }
            })

            this.rejectArr.push(reason =&amp;gt; {
                try {
                    let x = rejectFn(reason);

                    if(x instanceof MyPromise) {
                        x.then(resolve, reject)
                        return;
                    }

                    resolve(x);
                } catch(err) {
                    reject(err)
                }
            })
        })
    }

    catch(rejectFn) {
        return this.then(null, rejectFn)
    }

    static resolve(result) {
        // 返回新的promise实例，执行promise实例中resolve方法
        return new MyPromise(resolve =&amp;gt; {
            resolve(result)
        })
    }

    static reject(reason) {
        // 返回新的promise实例，执行promise实例中reject方法
        return new MyPromise((_, reject) =&amp;gt; {
            reject(reason);
        })
    }

    done(resolveFn, rejectFn) {
        this.then(resolveFn, rejectFn)
            .catch(reason =&amp;gt; {
                setTimeout(() =&amp;gt; {
                    throw reason;
                }, 0)
            })
    }

    finally(finallyFn) {
        let P = this.constructor;
        return this.then(
            value =&amp;gt; P.resolve(finallyFn()).then(() =&amp;gt; value),
            reason =&amp;gt; P.reject(finallyFn()).then(() =&amp;gt; reason)
        )
    }

    // 接收数组参数
    static all(promiseList) {
        // 返回新实例，调用后还可使用then、catch等方法
        return new MyPromise((resolve, reject) =&amp;gt; {
            let index = 0,      // 成功次数计数
                results = [];   // 返回的结果

            for(let i = 0; i &amp;lt; promiseList.length; i++) {
                let item = promiseList[i];

                // 如果item不是promise实例
                if(!(item instanceof MyPromise)) return;

                item.then(result =&amp;gt; {
                    index++;
                    results[i] = result;
                    if(index === promiseList.length) {
                        resolve(results);
                    }
                }).catch(reason =&amp;gt; {
                    reject(reason);
                })
            }
        })
    }

    static race(promiseList) {
        return new MyPromise((resolve, reject) =&amp;gt; {
            promiseList.forEach(item =&amp;gt; {
                if(!(item instanceof MyPromise)) return;

                item.then(result =&amp;gt; {
                    resolve(result);
                }).catch(err =&amp;gt; {
                    reject(err)
                })
            })
        })
    }

    static allSettled(promiseList) {
        return new MyPromise((resolve, reject) =&amp;gt; {
            let results = [];

            for(let i = 0; i &amp;lt; promiseList.length; i++) {
                let item = promiseList[i];

                if(!(item instanceof MyPromise)) return;

                item.then(result =&amp;gt; {
                    results[i] = result;
                }, reason =&amp;gt; {
                    results[i] = reason;
                })
                resolve(results);
            }
        })
    }




}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
</description>
        <pubDate>Tue, 11 May 2021 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2021/05/%E6%89%8B%E5%86%99promise%E5%AE%9E%E7%8E%B0/</link>
        <guid isPermaLink="true">http://localhost:4000/2021/05/%E6%89%8B%E5%86%99promise%E5%AE%9E%E7%8E%B0/</guid>
        
        <category>#promise</category>
        
        
      </item>
    
      <item>
        <title>react fiber</title>
        <description>&lt;h3 id=&quot;react-fiber-直接参考下面的文章目前见过讲得最好的一篇文章&quot;&gt;react fiber 直接参考下面的文章，目前见过讲得最好的一篇文章：&lt;/h3&gt;

&lt;p&gt;&lt;a href=&quot;http://www.ayqy.net/blog/dive-into-react-fiber/&quot;&gt;react fiber&lt;/a&gt;&lt;/p&gt;
</description>
        <pubDate>Sun, 09 May 2021 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2021/05/react-fiber/</link>
        <guid isPermaLink="true">http://localhost:4000/2021/05/react-fiber/</guid>
        
        <category>#react,</category>
        
        <category>#fiber</category>
        
        
      </item>
    
      <item>
        <title>（react）深入理解虚拟dom和diff算法</title>
        <description>&lt;h3 id=&quot;什么是虚拟-dom&quot;&gt;什么是虚拟 dom?&lt;/h3&gt;

&lt;p&gt;虚拟 dom 就是一个 js 对象。用 js 对象表示 DOM 信息和结构，当状态变更的时候，重新渲染这个 js 对象结构。这个 js 对象被称为 virtual dom.&lt;/p&gt;

&lt;h3 id=&quot;为什么要用虚拟-dom&quot;&gt;为什么要用虚拟 dom？&lt;/h3&gt;

&lt;p&gt;早先的时候，我们都是直接操作 dom（如：jquery）.&lt;/p&gt;

&lt;p&gt;这里，我们创建一个简单的 div，然后把他的所有的属性都打印出来：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    var div = document.createElement('div'),
        str = '';
    for (var key in div) {
      str = str + ' ' + key;
    }
    console.log(str);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;打印出来的结果：
&lt;img src=&quot;/assets/images/210509/divAttr.png&quot; alt=&quot;divAttr.png&quot; /&gt;
可以看到，这些属性还是非常惊人的，包括样式的修饰特性、一般的特性、方法等等，如果我们打印出其长度，可以得到惊人的 227 个。
而这仅仅是一层，真正的 DOM 元素是非常庞大的，这是因为标准就是这么设计的，而且操作他们的时候你要小心翼翼，轻微的触碰就有可能导致页面发生重排，这是杀死性能的罪魁祸首。&lt;/p&gt;

&lt;p&gt;而相对于 DOM 对象，原生的 JavaScript 对象处理起来更快，而且更简单，DOM 树上的结构信息我们都可以使用 JavaScript 对象很容易的表示出来。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;var element = {
      tagName: 'ul',
      props: {
        id: 'list'
      },
      children: {
        {
          tagName: 'li',
          props: {
            class: 'item'
          },
          children: ['Item1']
        },
        {
          tagName: 'li',
          props: {
            class: 'item'
          },
          children: ['Item1']
        },
        {
          tagName: 'li',
          props: {
            class: 'item'
          },
          children: ['Item1']
        }
      }
    }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;在哪里用到了虚拟-dom&quot;&gt;在哪里用到了虚拟 dom?&lt;/h3&gt;

&lt;p&gt;这就回到我们今天要说的。react 里面使用了虚拟 dom. React 里面就是把 jsx 转换成 js 对象。&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;jsx ?&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;
        &lt;p&gt;jsx 是一个语法糖，React 使用 jsx 来代替常规的 Javascript.
先看看使用 jsx 的代码：
&lt;img src=&quot;/assets/images/210509/jsx01.png&quot; alt=&quot;jsx01.png&quot; /&gt;&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;再看看不使用 jsx 的代码：
&lt;img src=&quot;/assets/images/210509/jsx02.png&quot; alt=&quot;jsx02.png&quot; /&gt;&lt;/p&gt;

        &lt;p&gt;react 里面使用 jsx 语法描述视图，通过 babel-loader 转译后它们变为 React.reateElement(…)形式。该函数将生成 vdom（虚拟 dom,即：js 对象）来描述真实 dom。如果状态发生变化，vdom 将作出相应的变化，再通过 diff 算法对比新老 vdom 区别从而作出最终 dom 的操作。
访问&lt;a href=&quot;https://www.babeljs.cn/repl#?browsers=defaults%2C%20not%20ie%2011%2C%20not%20ie_mob%2011&amp;amp;build=&amp;amp;builtIns=false&amp;amp;corejs=3.6&amp;amp;spec=false&amp;amp;loose=false&amp;amp;code_lz=MYewdgzgLgBFCWUA2BTGBeGAeAFgRhmCQEMIIA5YgWxXQCIFkU6A-ACRSSRABoYB3EACckAEwCEWAPT4WAbiA&amp;amp;debug=false&amp;amp;forceAllTransforms=false&amp;amp;shippedProposals=false&amp;amp;circleciRepo=&amp;amp;evaluate=false&amp;amp;fileSize=false&amp;amp;timeTravel=false&amp;amp;sourceType=module&amp;amp;lineWrap=true&amp;amp;presets=env%2Creact%2Cstage-2&amp;amp;prettier=false&amp;amp;targets=&amp;amp;version=7.14.1&amp;amp;externalPlugins=&quot;&gt;在线 babel 编辑器&lt;/a&gt;试一试。&lt;/p&gt;

        &lt;p&gt;如图示例：
&lt;img src=&quot;/assets/images/210509/babel.png&quot; alt=&quot;babel.png&quot; /&gt;&lt;/p&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;注意：
在 react17 之前，使用的是 React.createElement()进行 jsx 编译。
React17 中的 jsx 转换不会将 jsx 转换为 React.createElement(…),而是自动从 react 的 package 中引入新的函数并调用。另外，此次升级，不会改变 jsx 语法，旧的 jsx 转换也将继续工作。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;diff-算法&quot;&gt;diff 算法&lt;/h3&gt;

&lt;p&gt;参考：https://juejin.cn/post/6844904165026562056&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;diff 算法是什么？
diff 算法会比较前后虚拟 DOM，从而得到 patches(补丁)，然后与老 Virtual DOM 进行对比，将其应用在需要更新的地方，得到新的 Virtual DOM，在网上有一张非常直观的图可以帮忙参考
&lt;img src=&quot;/assets/images/210509/domDiff.png&quot; alt=&quot;domDiff.png&quot; /&gt;
来解释下这张图：现有一个真实的 DOM，首先会映射为虚拟 DOM，这个时候，我们删除了最后一个 p 节点和 son2 的节点，得到了新的一个虚拟 DOM，新的 vdom 会和旧的 vdom 进行差异对比，得到了 pathes 对象，之后，对旧的真实 dom 进行操作，得到了新的 DOM。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;diff 策略&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;
        &lt;p&gt;Web UI 中 DOM 节点跨层级的移动操作特别少，可以忽略不计。&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;拥有相同类的两个组件将会生成相似的树形结构，拥有不同类的两个组件将会生成不同的树形结构。&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;对于同一层级的一组子节点，它们可以通过唯一 id 进行区分。&lt;/p&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;基于以上三个策略，React 分别对 tree diff、component diff 以及 element diff 进行了算法优化。&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;
        &lt;p&gt;tree diff
基于第一个策略，react 只会对同一层次的节点进行比较，当发现节点不存在时，就会删除整个节点及其子节点，不会再进行比较，这样就只需要遍历一次，就能完成对整个 DOM 树的比较。
如果出现了 DOM 节点的跨层级的移动操作，React diff 会怎样呢？React 只会简单的考虑同层级节点的位置变换，对于不同层级的节点，只有创建和删除操作。&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;component diff
React 对于组件间的比较采取的策略也是简洁高效。
如果是同一类型的组件，按照原策略继续比较虚拟 dom 树；
如果不是，则将该组件判断为 dirty component，从而替换整个组件下的所有子节点；
对于同一类型的组件，有可能其 Virtual DOM 没有任何变化，如果能够确切的知道这点那可以节省大量的 diff 运算的时间，因此 React 允许用户通过 shouldComponentUpdate()判断该组件是否需要进行 diff。&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;element diff
当节点处于同一层级时，React diff 提供了三种节点操作：插入、移动和删除。
插入：新的 component 类型不在老集合里 -&amp;gt; 全新的节点，需要对新节点执行插入操作；
移动：在老集合里有新 component 类型，且 element 是可更新的类型，generateComponentChildren 已调用 receiveComponent，这种情况下 prevChild=nextChild，就需要做移动操作，可以复用以前的 dom 节点；
删除：老的 component 类型，在新集合中也有，但对应的 element 不同则不能直接复用和更新，需要执行删除操作，或者老 component 不在新集合里，也需要执行删除操作。&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;总结：
基于 diff 这样的策略，所以 react 建议我们用添加唯一 key 的方式来进行优化。&lt;/p&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;
</description>
        <pubDate>Sat, 08 May 2021 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2021/05/react-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%99%9A%E6%8B%9Fdom%E5%92%8Cdiff%E7%AE%97%E6%B3%95/</link>
        <guid isPermaLink="true">http://localhost:4000/2021/05/react-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%99%9A%E6%8B%9Fdom%E5%92%8Cdiff%E7%AE%97%E6%B3%95/</guid>
        
        <category>#react,</category>
        
        <category>#react</category>
        
        <category>virtual</category>
        
        <category>dom,</category>
        
        <category>#react</category>
        
        <category>diff算法</category>
        
        
      </item>
    
      <item>
        <title>算法的时间复杂度和空间复杂度</title>
        <description>&lt;h3 id=&quot;前言&quot;&gt;前言&lt;/h3&gt;

&lt;p&gt;如何衡量算法的优劣呢？主要从算法所占用的“时间”和“空间”去衡量。
时间维度：是指执行当前算法所消耗的时间，我们通常用【时间复杂度】来描述
空间维度：是指执行当前算法需要占用多少内存空间，我们通常用【空间复杂度】来描述&lt;/p&gt;

&lt;h3 id=&quot;大-o-复杂度表示法&quot;&gt;大 O 复杂度表示法&lt;/h3&gt;

&lt;p&gt;算法执行的效率。通俗的讲，就是算法代码执行的时间。
简单看个例子：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;var m = 0;
for(i=1; i&amp;lt;=n; ++i)
{
   j = i;
   j++;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;从 CPU 的角度来看，这段代码的每一行都执行着类似的操作：读数据-运算-写数据。尽管每行代码对应的 CPU 执行的个数、执行的时间都不一样，但是，我们这里只是粗略估计，所以可以假设每行代码执行的时间都一样，为 unit_time。在这个假设的基础之上，这段代码的总执行时间是多少呢？
line1 执行需要 1 个 unit_time 时间，line2,line4,line5 都执行的 n 遍，所以需要 n+n+n=3n 个 unit_time 的执行时间。所以这段代码的总执行时间就是：(1+3n)unit_time。
从这个结果可以看出，这个算法的耗时是【 随着 n 的变化而变化 】，因此，我们可以简化的将这个算法的时间复杂度表示为：T(n) = O(n)
为什么可以这么去简化呢，因为大 O 符号表示法并不是用于来真实代表算法的执行时间的，它是【 用来表示代码执行时间的增长变化趋势的 】。
所以上面的例子中，如果 n 无限大的时候，T(n) = time(1+3n)中的常量 1 就没有意义了，倍数 3 也意义不大。因此直接简化为 T(n) = O(n) 就可以了。&lt;/p&gt;

&lt;p&gt;在 大 O 符号表示法中，时间复杂度的公式是： T(n) = O( f(n) )，其中 f(n) 表示每行代码执行次数之和，而 O 表示正比例关系，这个公式的全称是：算法的渐进时间复杂度。&lt;/p&gt;

&lt;h3 id=&quot;时间复杂度&quot;&gt;时间复杂度&lt;/h3&gt;

&lt;p&gt;常见的时间复杂度量级有：&lt;/p&gt;

&lt;p&gt;常数阶 O(1)
对数阶 O(logN)
线性阶 O(n)
线性对数阶 O(nlogN)
平方阶 O(n²)
立方阶 O(n³)
K 次方阶 O(n^k)
指数阶(2^n)
上面从上至下依次的时间复杂度越来越大，执行的效率越来越低。&lt;/p&gt;

&lt;p&gt;选取上面几个来分析：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;常数阶 O(1)
无论执行了多少行，只要是没有循环等复杂结构，那这个代码的时间复杂度就是 O(1)，如：&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;var m = 0;
var n = 1;
var test = m + n;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;

    &lt;p&gt;上述代码在执行的时候，它消耗的时候并不随着某个变量的增长而增长，那么无论这类代码有多长，即使有几万几十万行，都可以用 O(1)来表示它的时间复杂度。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;线性阶 O(n)&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;var m = 1;
for(i=1; i&amp;lt;=n; ++i)
{
 m = i;
}

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;

    &lt;p&gt;这段代码，for 循环里面的代码会执行 n 遍，因此它消耗的时间是随着 n 的变化而变化的，因此这类代码都可以用 O(n)来表示它的时间复杂度。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;对数阶 O(logN)&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;var i = 1;
while(i&amp;lt;n)
{
    i = i * 2;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;

    &lt;p&gt;上面代码中，在 while 循环里，每次都将 i 乘以 2，乘完之后，i 距离 n 越来越近了。假设循环 x 次之后，i 就大于 n 了，此时这个循环就退出了。也就是说，2 的 x 次方等于 n。求出 x=log2(n) 即：log 以 2 为底 n 的对数。也就是说，当循环 log2(n)次以后，这个代码就结束了。因此这个代码的时间复杂度为：O(logn)&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;线性对数阶 O(nlogN)
线性对数阶 O(nlogN) 其实非常容易理解，将时间复杂度为 O(logn)的代码循环 N 遍的话，那么它的时间复杂度就是 n 乘以 O(logN)，也就是了 O(nlogN)。&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;for(var i=0; i&amp;lt;n; i++){
    m = 1
    while(m &amp;lt; n){
        m = m * 2
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;平方阶 O(n²)
把 O(n) 的代码再嵌套循环一遍，它的时间复杂度就是 O(n²)&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;var test = 1;
for(x=0; x&amp;lt;n; x++){
    for(y=0; y&amp;lt;n; y++){
        test = x+y
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;

    &lt;p&gt;如果将其中的一层循环 n 改成 m,那么时间复杂度就是 O(m*n)：&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;var test = 1;
for(x=0; x&amp;lt;m; x++){
    for(y=0; y&amp;lt;n; y++){
        test = x+y
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;空间复杂度&quot;&gt;空间复杂度&lt;/h3&gt;

&lt;p&gt;既然时间复杂度不是用来计算程序具体耗时的，那么空间复杂度也不是用来计算程序实际占用的空间的。
空间复杂度是对一个算法在运行过程中临时占用存储空间大小的一个衡量，同样反映的是一个趋势，用 S(n)来定义。&lt;/p&gt;

&lt;p&gt;空间复杂度比较常用的有：
O(1)、O(n)、O(n²)&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;空间复杂度 O(1)
如果算法执行所需要的临时空间不随着某个变量 n 的大小而变化，即此算法空间复杂度为一个常量，可表示为 O(1)
例如：&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;var i = 0;
var m = 1;
i++;
m++;
var n = m + i;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;

    &lt;p&gt;代码中的 i,m,n 所分配的空间都不随着处理数据变化，因此它的空间复杂度为 S(n) = O(1)&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;空间复杂度 O(n)&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;int[] m = new int[n]
for(i=1; i&amp;lt;=n; ++i)
{
 j = i;
 j++;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;

    &lt;p&gt;这段代码中，line1 new 了一个数组出来，这个数据占用的大小为 n,这段代码的 line2-6, 虽然有循环，但是没有再分配新的空间，因此这段代码的空间复杂度主要看第一行即可。即：S(n) = O(n)&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;function print(n) {
     var i = 0;
     var a = [];
     for (i; i &amp;lt;n; ++i) {
         a[i] = i * i;
     }
     for (i = n-1; i &amp;gt;= 0; --i) {
         console.log(a[i])
     }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;

    &lt;p&gt;这段代码也是，代码中，line2 申请了一个空间存储变量 i，但是它是常量阶的，跟数据规模 n 没有关系，所以我们可以忽略。line3 申请了一个大小为 n 的 int 类型数组，除此之外，剩下的代码都没有占用更多的空间，所以整段代码的空间复杂度就是 O(n)。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;
</description>
        <pubDate>Sat, 08 May 2021 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2021/05/%E7%AE%97%E6%B3%95%E7%9A%84%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%92%8C%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6/</link>
        <guid isPermaLink="true">http://localhost:4000/2021/05/%E7%AE%97%E6%B3%95%E7%9A%84%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%92%8C%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6/</guid>
        
        <category>#时间复杂度,</category>
        
        <category>#空间复杂度</category>
        
        
      </item>
    
      <item>
        <title>解决oninput事件在中文输入法下会取得拼音的值的问题</title>
        <description>&lt;h3 id=&quot;前言&quot;&gt;前言&lt;/h3&gt;

&lt;p&gt;如果直接通过 input 监听输入框输入，它会在键盘按键按下的时候就触发事件，这样就会导致一些问题，比如在 chrome 浏览器中，想输入中文输入不了。
解决方法是，用 compositionstart 和 compositionend.&lt;/p&gt;

&lt;p&gt;注意：chrome 和 safari 浏览器（webkit 内核）跟其他浏览器的执行顺序不同，
chrome 和 safari 是 compositionstart =&amp;gt; 监听 input 事件 =&amp;gt; compositionend,&lt;br /&gt;
其他浏览器是 compositionstart =&amp;gt; compositionend =&amp;gt; 监听 input 事件。
所以，在 compositionend 浏览器里面要判断一下是否是谷歌浏览器。&lt;/p&gt;

&lt;h3 id=&quot;上代码&quot;&gt;上代码&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    // 输入框事件
    const searchInputDom = document.getElementById('search-input');

    // 解决oninput事件在中文输入法下会取得拼音的值的问题
    let isInputZh = false;

    searchInputDom.addEventListener('compositionstart', (e)=&amp;gt; {
        console.log('compositionstart')
        isInputZh = true;
    }, false);

    searchInputDom.addEventListener('compositionend',  (e)=&amp;gt; {
        console.log('compositionend')
        isInputZh = false;

        // 判断是否是webkit内核
        if(!isInputZh &amp;amp;&amp;amp; isWebkit()){
            toSearch(searchInputDom.value)
        }

    }, false);

    searchInputDom.oninput= (e) =&amp;gt; {
      console.log('oninput')
      if(isInputZh) return;
      toSearch(e.target.value)
    };



    // 判断是否是chrome or safari
    function isWebkit(){
        var browser = {
            versions: function() {
                var u = navigator.userAgent, app = navigator.appVersion;
                return {
                    trident: u.indexOf('Trident') &amp;gt; -1, //IE内核
                    presto: u.indexOf('Presto') &amp;gt; -1, //opera内核
                    webKit: u.indexOf('AppleWebKit') &amp;gt; -1, //苹果、谷歌内核
                    gecko: u.indexOf('Gecko') &amp;gt; -1 &amp;amp;&amp;amp; u.indexOf('KHTML') == -1, //火狐内核
                    mobile: !!u.match(/AppleWebKit.*Mobile.*/) || !!u.match(/AppleWebKit/), //是否为移动终端
                    ios: !!u.match(/\(i[^;]+;( U;)? CPU.+Mac OS X/), //ios终端
                    android: u.indexOf('Android') &amp;gt; -1 || u.indexOf('Linux') &amp;gt; -1, //android终端或者uc浏览器
                    iPhone: u.indexOf('iPhone') &amp;gt; -1 || u.indexOf('Mac') &amp;gt; -1, //是否为iPhone或者QQHD浏览器
                    iPad: u.indexOf('iPad') &amp;gt; -1, //是否iPad
                    webApp: u.indexOf('Safari') == -1 //是否web应该程序，没有头部与底部
                };
            }(),
            language: (navigator.browserLanguage || navigator.language).toLowerCase()
        }

        if(browser.versions.webKit){
            return true;
        }

        return false;
    }

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
</description>
        <pubDate>Fri, 07 May 2021 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2021/05/%E8%A7%A3%E5%86%B3oninput%E4%BA%8B%E4%BB%B6%E5%9C%A8%E4%B8%AD%E6%96%87%E8%BE%93%E5%85%A5%E6%B3%95%E4%B8%8B%E4%BC%9A%E5%8F%96%E5%BE%97%E6%8B%BC%E9%9F%B3%E7%9A%84%E5%80%BC%E7%9A%84%E9%97%AE%E9%A2%98/</link>
        <guid isPermaLink="true">http://localhost:4000/2021/05/%E8%A7%A3%E5%86%B3oninput%E4%BA%8B%E4%BB%B6%E5%9C%A8%E4%B8%AD%E6%96%87%E8%BE%93%E5%85%A5%E6%B3%95%E4%B8%8B%E4%BC%9A%E5%8F%96%E5%BE%97%E6%8B%BC%E9%9F%B3%E7%9A%84%E5%80%BC%E7%9A%84%E9%97%AE%E9%A2%98/</guid>
        
        <category>#input,</category>
        
        <category>#oninput事件,</category>
        
        <category>#中文输入法,</category>
        
        <category>#浏览器兼容性</category>
        
        
      </item>
    
      <item>
        <title>vue中input的blur影响下拉框中click事件</title>
        <description>&lt;h3 id=&quot;问题描述&quot;&gt;问题描述:&lt;/h3&gt;

&lt;p&gt;存在如下一段代码：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;lt;input ref=&quot;input&quot; class=&quot;search-box&quot; placeholder=&quot;请输入要搜索的内容&quot; v-model=&quot;keyWords&quot; @input=&quot;search()&quot; @focus=&quot;focusSearch()&quot; @blur=&quot;onBlur()&quot;/&amp;gt;

&amp;lt;div class=&quot;result-list&quot; v-if=&quot;showComplete&quot;&amp;gt;
    &amp;lt;div class=&quot;result-item&quot; v-if=&quot;searchResultList.length === 0&quot;&amp;gt;没有找到对应内容&amp;lt;/div&amp;gt;
    &amp;lt;div class=&quot;result-item&quot; v-for=&quot;r in searchResultList&quot; :key=&quot;r.id&quot; @click=&quot;toSearch([r])&quot;&amp;gt;&amp;lt;/div&amp;gt;
&amp;lt;/div&amp;gt;

onBlur(){
    console.log('blur')
    this.showComplete = false
}
toSearch(nodes){
    console.log('click')
    // do sth...
    this.$nextTick(()=&amp;gt;{
        this.keyWords = '';
    })
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;输入框输入关键字搜索，选择下拉框里匹配的某一条数据后，click 无法执行。主要原因是。blur 的优先级比 click 高，先触发了 blur 事件 showComplete = false,下拉列表注销，click 无法执行。&lt;/p&gt;

&lt;h3 id=&quot;解决办法&quot;&gt;解决办法&lt;/h3&gt;

&lt;ol&gt;
  &lt;li&gt;解决办法一：blur 执行的函数可以加个定时器，在 200ms 后执行&lt;/li&gt;
&lt;/ol&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;onBlur(){
      console.log('blur')
      setTimeout(()=&amp;gt;{
        this.showComplete = false
      },200)
},
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ol&gt;
  &lt;li&gt;解决办法二：将 click 换成优先级更高的 mousedown，将优先于 blur 执行&lt;/li&gt;
&lt;/ol&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;lt;div class=&quot;result-item&quot; v-for=&quot;r in searchResultList&quot; :key=&quot;r.id&quot; @mousedown=&quot;toSearch([r])&quot;&amp;gt;&amp;lt;/div&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
</description>
        <pubDate>Fri, 07 May 2021 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2021/05/vue%E4%B8%ADinput%E7%9A%84blur%E5%BD%B1%E5%93%8D%E4%B8%8B%E6%8B%89%E6%A1%86%E4%B8%ADclick%E4%BA%8B%E4%BB%B6/</link>
        <guid isPermaLink="true">http://localhost:4000/2021/05/vue%E4%B8%ADinput%E7%9A%84blur%E5%BD%B1%E5%93%8D%E4%B8%8B%E6%8B%89%E6%A1%86%E4%B8%ADclick%E4%BA%8B%E4%BB%B6/</guid>
        
        <category>#vue，</category>
        
        <category>#input,</category>
        
        <category>#blur,</category>
        
        <category>#click</category>
        
        
      </item>
    
      <item>
        <title>json tree形数据查找复合条件的json tree数据</title>
        <description>&lt;h3 id=&quot;需求描述&quot;&gt;需求描述&lt;/h3&gt;

&lt;p&gt;存在一个 json tree 形数据：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;var treeData = [
    {
        id: 'root',
        name: '食物',
        children: [
            {
                id: '1',
                name: '水果',
                children: [
                    {
                        id: '1-1',
                        name: '水果-苹果',
                        children: []
                    },
                    {
                        id: '1-2',
                        name: '香蕉',
                        children: []
                    }
                ]
            },
            {
                id: '2',
                name: '主食',
                children: [
                    {
                        id: '2-1',
                        name: '主食-米饭',
                        children: []
                    },
                    {
                        id: '2-2',
                        name: '面条',
                        children: []
                    },
                    {
                        id: '2-3',
                        name: '米线',
                        children: []
                    }
                ]
            },
            {
                id: '3',
                name: '零食',
                children: [
                    {
                        id: '3-1',
                        name: '瓜子',
                        children: []
                    },
                    {
                        id: '3-2',
                        name: '花生',
                        children: []
                    },
                    {
                        id: '3-3',
                        name: '蚕豆',
                        children: []
                    }
                ]
            }
        ]
    }
]
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;输入框搜索关键词，如：“水果”，一旦发现某一层级的 name 匹配上了关键词，则返回这一层级以及他的所有子元素。
返回的数据应该如下：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;var searchResult = [
    {
        id: 'root',
        name: '食物',
        children: [
            {
                id: '1',
                name: '水果',
                children: [
                    {
                        id: '1-1',
                        name: '水果-苹果',
                        children: []
                    },
                    {
                        id: '1-2',
                        name: '香蕉',
                        children: []
                    }
                ]
            }
    }
]
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;算法如下：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    // tree search
    handleTreeData(treeData, searchValue) {
      if (!treeData || treeData.length === 0) {
        return [];
      }
      const array = [];
      for (let i = 0; i &amp;lt; treeData.length; i += 1) {
        const nodeName = treeData[i].name.toLowerCase()
        const searchName = searchValue.toLowerCase()
        if (this.handleTreeData(treeData[i].children, searchValue).length &amp;gt; 0 || nodeName.includes(searchName)) {
          let obj = {
            ...treeData[i]
          }
          if(!nodeName.includes(searchName)){
            // 父节点name不包含searchVal,则继续查找。否则，子节点不用查找，把父节点和父节点的children直接返回
            obj.children = this.handleTreeData(treeData[i].children, searchValue)
          }
          array.push(obj)
        }
      }
      return array;
    }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
</description>
        <pubDate>Fri, 07 May 2021 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2021/05/json-tree%E5%BD%A2%E6%95%B0%E6%8D%AE%E6%9F%A5%E6%89%BE%E5%A4%8D%E5%90%88%E6%9D%A1%E4%BB%B6%E7%9A%84json-tree%E6%95%B0%E6%8D%AE/</link>
        <guid isPermaLink="true">http://localhost:4000/2021/05/json-tree%E5%BD%A2%E6%95%B0%E6%8D%AE%E6%9F%A5%E6%89%BE%E5%A4%8D%E5%90%88%E6%9D%A1%E4%BB%B6%E7%9A%84json-tree%E6%95%B0%E6%8D%AE/</guid>
        
        <category>#input,</category>
        
        <category>#oninput事件,</category>
        
        <category>#中文输入法,</category>
        
        <category>#浏览器兼容性</category>
        
        
      </item>
    
      <item>
        <title>谈谈vue-router</title>
        <description>&lt;h3 id=&quot;vue-router-对不同模式的实现大致是这样的&quot;&gt;vue-router 对不同模式的实现大致是这样的：&lt;/h3&gt;

&lt;ol&gt;
  &lt;li&gt;首先根据 mode 来确定所选的模式，如果当前环境不支持 history 模式，会强制切换到 hash 模式；&lt;/li&gt;
  &lt;li&gt;如果当前环境不是浏览器环境，会切换到 abstract 模式下。然后再根据不同模式来生成不同的 history 操作对象。&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;new-vuerouter-过程&quot;&gt;new VueRouter 过程&lt;/h3&gt;

&lt;ol&gt;
  &lt;li&gt;init 方法内的 app 变量便是存储的当前的 vue 实例的 this。&lt;/li&gt;
  &lt;li&gt;将 app 存入数组 apps 中。通过 this.app 判断是实例否已经被初始化。&lt;/li&gt;
  &lt;li&gt;通过 history 来确定不同路由的切换动作 history.transitionTo。&lt;/li&gt;
  &lt;li&gt;通过 history.listen 来注册路由变化的响应回调。&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;hash-和-history-的区别&quot;&gt;hash 和 history 的区别&lt;/h3&gt;

&lt;ol&gt;
  &lt;li&gt;最明显的是在显示上，hash 模式的 URL 中会夹杂着#号，而 history 没有。&lt;/li&gt;
  &lt;li&gt;Vue 底层对它们的实现方式不同。hash 模式是依靠 onhashchange 事件(监听 location.hash 的改变)，而 history 模式（popstate）是主要是依靠的 HTML5 history 中新增的两个方法，pushState()可以改变 url 地址且不会发送请求，replaceState()可以读取历史记录栈，还可以对浏览器记录进行修改。&lt;/li&gt;
  &lt;li&gt;当真正需要通过 URL 向后端发送 HTTP 请求的时候，比如常见的用户手动输入 URL 后回车，或者是刷新(重启)浏览器，这时候 history 模式需要后端的支持。因为 history 模式下，前端的 URL 必须和实际向后端发送请求的 URL 一致，例如有一个 URL 是带有路径 path 的(例如www.lindaidai.wang/blogs/id)，如果后端没有对这个路径做处理的话，就会返回404错误。所以需要后端增加一个覆盖所有情况的候选资源，一般会配合前端给出的一个404页面。&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;vue-history-配置&quot;&gt;vue history 配置&lt;/h3&gt;

&lt;p&gt;vue history 需要 nginx 或者其他方式配置一下才可正确访问，否则路由跳转之后刷新一下便会出现 404。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;vue history 模式 部署在服务器端的 nginx 配置，配置如下：&lt;/li&gt;
&lt;/ul&gt;

&lt;ol&gt;
  &lt;li&gt;根路径配置：&lt;/li&gt;
&lt;/ol&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;server {

        listen      443 ;

        server_name  m;

        root  html/mobile;

        location / {

            index  index.html index.htm;

            try_files $uri $uri/ /index.html;

        }

    }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;路由配置：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;const router=new VueRouter({
  mode: 'history',
  routes
})
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ol&gt;
  &lt;li&gt;非根路径配置：&lt;/li&gt;
&lt;/ol&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;server {
        location ^~/A {

            index  index.html

            try_files $uri $uri/ /A/index.html;

        }

        location ^~/B {

            index  index.html

            try_files $uri $uri/ /B/index.html;

        }

    }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;路由配置：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;A 项目：&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;const router=new VueRouter({
  mode: 'history',
  routes,
  base: '/A'
})
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;B 项目：&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;const router=new VueRouter({
  mode: 'history',
  routes,
  base: '/B'
})
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;缓存策略&quot;&gt;缓存策略&lt;/h3&gt;

&lt;p&gt;设置某些文件不使用缓存：
location = /index.html {
add_header Cache-Control “no-cache, no-store”;
}
location = /lib/sdk.js {
add_header Cache-Control “no-cache, no-store”;
}&lt;/p&gt;
</description>
        <pubDate>Mon, 12 Apr 2021 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2021/04/%E8%B0%88%E8%B0%88vueRouter/</link>
        <guid isPermaLink="true">http://localhost:4000/2021/04/%E8%B0%88%E8%B0%88vueRouter/</guid>
        
        <category>#vue,</category>
        
        <category>#vue-router,</category>
        
        <category>#hash,</category>
        
        <category>#history</category>
        
        
      </item>
    
  </channel>
</rss>
